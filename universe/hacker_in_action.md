---
title: 黑客攻防系统实战学习
date: 2020-5-21
tags: hacker,汇编
---

前置知识：汇编语言

## 栈溢出

缓冲区是一片有限的、连续的内存区域。在C语言中最常见的缓冲区是数组。

因为在C和C++语言中没有考虑检查缓冲区的内在边界，所以使栈溢出成为可能。当输入的数据足够大时，将会溢出缓冲区的范围，从而改写从而改写其他缓存区域。


### 函数与栈

调用函数的整个过程如下
- 1. 把函数的参数压入栈
- 2. 把函数的返回地址压入栈
    - 主程序调用子程序，子程序结束后继续上次的位置执行主程序
- 3. 调用函数

为了使函数可以引用栈上的数据，必须改变栈底指针EBP的值，把EBP的当前值压入栈，把当前的栈顶ESP复制到EBP，函数接受后再恢复。这样我们就可以方便地引用栈地址了。

接着编译器计算函数的局部变量所需的地址空间和栈上的保留空间，然后从ESP减去变量的大小，为程序保留必要的空间，最后把函数的局部变量压入栈(这我们举例：数组)。结构如下：

| 低内存地址，栈顶 |
|------------------|
| 数组             |
| EBP              |
| RET              |
| 参数             |
| 高内存地址，栈底 |


### 栈上的缓冲区溢出

由上述结构可见，如果数组很大，将会溢出，然后改写其他缓存区域。

- 控制EIP
    - CPU执行什么指令由CS:IP的指向决定
    - 我们只要精心设计溢出的数据，这些地址将写入缓冲器并改写保留在缓冲区的EBP和RET。当系统从栈中取出RET的值并放入EIP时，这个地址指向的指令将被执行。


### 利用漏洞获得root权限

我们可以攻击以root权限运行的进程，通过溢出强制它执行shell，这个shell将继承root权限。然而缓冲区只认得机器指令(opcode)。为了把opcode插入缓存区，必须吧派生的shell的C代码编译成汇编指令，然后从可读的汇编指令中提取opcode。这些被称为shellcode或opcode的代码可以注入缓冲区，并可执行。


#### 地址问题

当试图执行用户提交的shellcode时，所面临的问题是找出shellcode的起始地址。(想办法使EIP指向这个地址)

先介绍一种使用最广的方法：猜。每个程序的栈都以同样的地址开始。(现在大多数操作系统故意变化栈地址，从而使这类的攻击变得困难)知道这个地址就可以猜测shellcode的起始地址和RET的地址。

- 首先要知道ESP的地址，那么根据这个地址来猜测当前地址和shellcode之间的偏移距离。从而的到shellcode的起始地址
- 通过尝试输入过长数据造成溢出，从造成故障的长度来猜测RET地址
- 最后把RET地址改为shellcode的起始地址以达到执行shellcode的目的


**例1** ：简单试炼，破解以下程序，假设我们不知道被攻击程序的内部结构

``` c
// victim.c

int main(int argc, char *argv){
    char array[512];

    if(argc>1){
        strcpy(array, argv[1]);
    }
}
```

- 如果每个程序的栈都是以同样的地址开始，则固定的程序RET地址不会改变，我们可以通过溢出找出RET地址
    - `$ ./victim.c $(printf "%0524" 0)`利用bash快速尝试输入多个0(长数据)
- 假设我们的shellcode有40B，上一步在524个数据时溢出，那么我们可以将上一步的长数据改成`shellcode+(524-len(shellcode))个0+shellcode起始地址`
    - 这里还没获得shellcode起始地址，我们先用别的地址测试填充0的个数是否正确


building...


#### NOP法

一个个猜太过麻烦，可以选用NOP法来增加潜在的偏移量的数量。思路就是创建一大段不运行的指令区，放在shellcode前面，当执行完NOP之后，就会执行shellcode。这样就不用精确地猜到偏移量了。


### 战胜不可执行栈

前面所讲的漏洞利用程序能工作，是因为可以在栈上执行指令。许多操作系统不允许在栈上执行代码。当遇到不可执行栈的时候，可以用"返回libc"方法。

栈溢出原理上其实是利用了EIP指针，那么如果我们可以完全EIP指针，那么就可以把任意想执行的代码放入EIP。返回libc是把控制权交给特定的动态库函数。动态库函数不在栈上，所以我们就可以绕开不可执行栈的限制。

为了攻击成功，需要仔细挑选动态库函数。理论上，它必须符合以下两个条件：
- 它必须的常见的动态库函数，在绝大多数程序中出现，才便于利用
- 函数库里的函数应该给予我们很大的灵活性，以便我们能派生shell或做其他事

libc就是满足条件的一个库函数。我们只要把执行流程指向想用的库函数的地址，它将被执行。

以下以派生shell讨论。最好用的libc函数是system()。system()接受一个参数，然后用/bin/sh/执行这个参数。根据经验主程序执行一个函数(设为func)时，参数入栈的顺序和它在代码里的顺序相反，根据这点，我们需要进行以下工作：
- 确定system()地址
    - 主程序执行一个函数func时，call func，会把返回地址RET压入栈
- 确定/bin/sh地址(参数地址)
    - 第一个参数位于RET之后
- 找出exit()地址，以便干净地退出被攻击的程序

用memfetch工具可以找到/bin/sh的地址，memfetch的功能是把指定进程的内存数据全部转存到一个二进制文件中，我们可以在这个文件里找/bin/sh的地址

破解过程如下：
- 1. 用垃圾数据填满缓冲区和返回地址之间的空间
- 2. 用system()的地址改写返回地址
- 3. 在system()后加上exit()的地址
- 4. 再加上/bin/sh的地址


## shellcode

shellcode是一组可注入(机械码)的程序，可以在被攻击的程序里运行。因为shellcode要直接操作寄存器和程序的函数，所以通常用汇编语言编写并翻译为十六进制操作码。之所以叫shellcode是因为通常用这种操作来派生root权限的shell。


### 理解系统调用

我们想让目标程序不同于设计者预期的方式运行，而操纵程序的方法之一是强制它产生系统调用(中断)。可以通过系统调用访问特定的操作系统的函数，如接受输入、处理输出、退出进程、执行二进制文件等。

通过系统调用可以直接访问系统内核，即可以访问读写文件之类的低级函数。系统调用也是受保护的内核模式与用户模式之间的接口。受保护的内核模式会阻止用户的应用程序干涉或危及操作系统。当用户模式下的程序企图访问内核的内存空间时，系统将产生异常。但是，某些程序在正常运行时，需要请求一些系统级的服务，这时系统调用就作为正常用户模式和内核模式之间的接口，在保证安全的情况下尽量相应这些请求。

在Linux里有两种方法来执行系统调用：
- 间接方法：C库函数(libc)
- 直接方法：汇编指令(把适当的参数加载到寄存器，然后调用中断)执行系统调用

在Linux里，程序通过`int 0x80`软中断来执行系统调用。当程序在用户模式下执行`int 0x80`时，CPU切换到内核模式并执行相应的系统调用。系统调用的过程如下：
- 1. 把系统调用编号载入EAX，通过载入编号来调用对应系统函数
- 2. 把系统调用的参数压入其它寄存器
- 3. 执行`int 0x80`指令
- 4. CPU切换到内核模式
- 5. 执行系统函数

思考下列程序：

``` c
main(){
     exit(0);
}
// gcc -static -o exit exit.c
```

反汇编生成的二进制文件：

``` 
$ gdb exit
(gdb) disas _exit
address <line>: mov 0x4(%esp,1),%ebx
address <line>: mov $Oxfc,%eax          ;对应的系统调用编号被放入%EAX中
address <line>: int $0x80               ;通过int 0x80指令得知发生了系统调用
address <line>: mov $0x1,%eax           ;对应的系统调用编号被放入%EAX中
address <line>: int $0x80
address <line>: hlt
address <line>: nop
```

exit()对应的系统调用编号是1，exit\_group()对应的系统调用编号是252。在反汇编生成的代码里还有一条指令，它把系统调用的参数加载到EBX。这个参数是0，是在系统调用之前入栈的`mov 0x4(%esp,1),%ebx`

`int 0x80`指令把CPU切换到内核模式，并且执行系统调用


### 为exit()系统调用写shellcode

> 较小的shellcode可以注入更多的缓冲区，可以用来攻击更多的程序，所以要使shellcode尽量保持简单、紧凑。当攻击问题程序的时候，不仅要把shellcode复制到缓冲区，如果碰到n字节长的缓冲区，不仅要把整个shellcode复制到它里面，还要加上调用shellcode的指令，因此shellcode的长度必须小于n。基于这个原因，shellcode应尽量小。
























