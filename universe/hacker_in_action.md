---
title: 黑客攻防系统实战学习
date: 2020-5-21
tags: hacker,汇编
---

前置知识：汇编语言

## 栈溢出

缓冲区是一片有限的、连续的内存区域。在C语言中最常见的缓冲区是数组。

因为在C和C++语言中没有考虑检查缓冲区的内在边界，所以使栈溢出成为可能。当输入的数据足够大时，将会溢出缓冲区的范围，从而改写从而改写其他缓存区域。


### 函数与栈

调用函数的整个过程如下
- 1. 把函数的参数压入栈
- 2. 把函数的返回地址压入栈
    - 主程序调用子程序，子程序结束后继续上次的位置执行主程序
- 3. 调用函数

为了使函数可以引用栈上的数据，必须改变栈底指针EBP的值，把EBP的当前值压入栈，把当前的栈顶ESP复制到EBP，函数接受后再恢复。这样我们就可以方便地引用栈地址了。

接着编译器计算函数的局部变量所需的地址空间和栈上的保留空间，然后从ESP减去变量的大小，为程序保留必要的空间，最后把函数的局部变量压入栈(这我们举例：数组)。结构如下：

| 低内存地址，栈顶 |
|------------------|
| 数组             |
| EBP              |
| RET              |
| 参数             |
| 高内存地址，栈底 |


### 栈上的缓冲区溢出

由上述结构可见，如果数组很大，将会溢出，然后改写其他缓存区域。

- 控制EIP
    - CPU执行什么指令由CS:IP的指向决定
    - 我们只要精心设计溢出的数据，这些地址将写入缓冲器并改写保留在缓冲区的EBP和RET。当系统从栈中取出RET的值并放入EIP时，这个地址指向的指令将被执行。


### 利用漏洞获得root权限

我们可以攻击以root权限运行的进程，通过溢出强制它执行shell，这个shell将继承root权限。然而缓冲区只认得机器指令(opcode)。为了把opcode插入缓存区，必须吧派生的shell的C代码编译成汇编指令，然后从可读的汇编指令中提取opcode。这些被称为shellcode或opcode的代码可以注入缓冲区，并可执行。


#### 地址问题

当试图执行用户提交的shellcode时，所面临的问题是找出shellcode的起始地址。(然后使EIP指向这个地址)

















