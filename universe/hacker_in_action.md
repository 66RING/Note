---
title: 黑客攻防系统实战学习
date: 2020-5-21
tags: hacker,汇编
---

前置知识：汇编语言

## 栈溢出

缓冲区是一片有限的、连续的内存区域。在C语言中最常见的缓冲区是数组。

因为在C和C++语言中没有考虑检查缓冲区的内在边界，所以使栈溢出成为可能。当输入的数据足够大时，将会溢出缓冲区的范围，从而改写从而改写其他缓存区域。


### 函数与栈

调用函数的整个过程如下
- 1. 把函数的参数压入栈
- 2. 把函数的返回地址压入栈
    - 主程序调用子程序，子程序结束后继续上次的位置执行主程序
- 3. 调用函数

为了使函数可以引用栈上的数据，必须改变栈底指针EBP的值，把EBP的当前值压入栈，把当前的栈顶ESP复制到EBP，函数接受后再恢复。这样我们就可以方便地引用栈地址了。

接着编译器计算函数的局部变量所需的地址空间和栈上的保留空间，然后从ESP减去变量的大小，为程序保留必要的空间，最后把函数的局部变量压入栈(这我们举例：数组)。结构如下：

| 低内存地址，栈顶 |
|------------------|
| 数组             |
| EBP              |
| RET              |
| 参数             |
| 高内存地址，栈底 |


### 栈上的缓冲区溢出

由上述结构可见，如果数组很大，将会溢出，然后改写其他缓存区域。

- 控制EIP
    - CPU执行什么指令由CS:IP的指向决定
    - 我们只要精心设计溢出的数据，这些地址将写入缓冲器并改写保留在缓冲区的EBP和RET。当系统从栈中取出RET的值并放入EIP时，这个地址指向的指令将被执行。


### 利用漏洞获得root权限

我们可以攻击以root权限运行的进程，通过溢出强制它执行shell，这个shell将继承root权限。然而缓冲区只认得机器指令(opcode)。为了把opcode插入缓存区，必须吧派生的shell的C代码编译成汇编指令，然后从可读的汇编指令中提取opcode。这些被称为shellcode或opcode的代码可以注入缓冲区，并可执行。


#### 地址问题

当试图执行用户提交的shellcode时，所面临的问题是找出shellcode的起始地址。(想办法使EIP指向这个地址)

先介绍一种使用最广的方法：猜。每个程序的栈都以同样的地址开始。(现在大多数操作系统故意变化栈地址，从而使这类的攻击变得困难)知道这个地址就可以猜测shellcode的起始地址和RET的地址。

- 首先要知道ESP的地址，那么根据这个地址来猜测当前地址和shellcode之间的偏移距离。从而的到shellcode的起始地址
- 通过尝试输入过长数据造成溢出，从造成故障的长度来猜测RET地址
- 最后把RET地址改为shellcode的起始地址以达到执行shellcode的目的


**例1** ：简单试炼，破解以下程序，假设我们不知道被攻击程序的内部结构

``` c
// victim.c

int main(int argc, char *argv){
    char array[512];

    if(argc>1){
        strcpy(array, argv[1]);
    }
}
```

- 如果每个程序的栈都是以同样的地址开始，则固定的程序RET地址不会改变，我们可以通过溢出找出RET地址
    - `$ ./victim.c $(printf "%0524" 0)`利用bash快速尝试输入多个0(长数据)
- 假设我们的shellcode有40B，上一步在524个数据时溢出，那么我们可以将上一步的长数据改成`shellcode+(524-len(shellcode))个0+shellcode起始地址`
    - 这里还没获得shellcode起始地址，我们先用别的地址测试填充0的个数是否正确


building...


#### NOP法

一个个猜太过麻烦，可以选用NOP法来增加潜在的偏移量的数量。思路就是创建一大段不运行的指令区，放在shellcode前面，当执行完NOP之后，就会执行shellcode。这样就不用精确地猜到偏移量了。

    



















