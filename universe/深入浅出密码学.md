---
title: 密码学
date: 2020-5-4
tage: 密码学
mathjax: true
---

## 密码学和数据安全导论

可靠的密码体制必须遵守Auguste Kerekhoffs在1883年提出的一个假说，即Kerekhoffs原理:

> 即使密钥外的整个系统的一切都是公开的，这个密码体制也必须是安全的。尤其是即使攻击者知道系统的加密算法和解密算法，此系统也必须是安全的。

需要强调的是，设计上一个隐藏细节的系统看似是更安全的。但是历史经验告诉我们这样的系统其实是很脆弱的，系统的细节可以通过逆向工程破解。这就是说为什么即使攻击者知道加密算法，加密方案仍必须保持安全的原因。


### 模运算与多种古典密码

#### 模运算

几乎所有的加密算法都是基于有限个元素的运算。模运算就是在有限个数集中执行运算的简单方法：

定义：模运算
> 假设$a, r, m \in Z$(其中Z是所有整数的集合)，并且m>0。如果m除a-r，可记作：
> $$a = r \bmod m$$
> 其中m称为模数，r称为余数


##### 等价类中所有成员的等价行为

对于一个给定模数m，选择等价类中任何一个元素用于计算的结果都是一样的。因此我们可以选择等价类中最易于计算的一个元素进行模运算

计算$3^8$模7的的结果：
- $3^8 = 6561 = 2 \bmod 7$
- 下面使用等价类进行计算
$$3^8 = 3^4 \cdot 3^4 = 81 \cdot 81$$
- 然后将中间结果的81替换为同一等价类中的其他元素。在模数7的等价类中，最小的正元素是4(因为$81 = 11 \cdot 7 + 4$)，因此：
$$3^8 = 3^4 \cdot 3^4 = 4 \cdot 4 = 16 \bmod 7 = 2 \bmod 7$$

通用的规则是：应该尽量使用模化简，使计算的数值尽可能小，这样做总是极具计算优势


#### 整数环

定义：环
> 整数环$Z_m$由以下两部分组成：
> - 1. 集合$Z_m = (0, 1, 2, ..., m-1)$
> - 2. 两种操作"+"和"×"，使得所有的$a, b \in Z_m$有
>     - 1)$a + b = c \bmod m, (c \in Z_m)$
>     - 2)$a \times b = d \bmod m, (d \in Z_m)$

环具有以下特征：
- 如果环内任何两个数相加或相乘得到的结果始终在环内，那么这个环是封闭的
- 加法和乘法是可结合的，例如对所有的$a, b, c \in Z_m$，都有$a + (b+c) = (a+b) + c$和$a \cdot (b \cdot c) = (a \cdot b) \cdot c$
- 加法中存在中性元素0，使得对每个$a \in Z_m$都有$a + 0 = a \bmod m$
- 环中的任何元素a都存在一个负元素-a，使得$a + (-a) = 0 \bmod m$，即加法逆元始终存在
- 乘法中存在中性元素1，使得对每个$a \in Z_m$都有$a \times 1 = a \bmod m$
- 不是所有元素都存在乘法逆元，假设$a \in Z$，乘法逆元$a^{-1}$可以定义为：
$$a \times a^{-1} = 1 \mod m$$
如果某个元素的乘法逆元存在，则可以除以这个元素，因为$b/a = b \cdot a^{-1} \bmod m$
- 寻找逆元比较困难，可以通过一种简单的方法判断一个元素a的逆元是否存在：
    - 当且仅当$gcd(a, m) = 1$，一个元素$a \in Z$存在乘法逆元$a^{01}$，其中gcd表示最大公约数(Greatest Common divisor)，$gcd(a, m) = 1$就表示a和m(模数)互质


#### 仿射密码

仿射密码是一种改善的移位密码，仿射密码的思路是将明文密码乘以密钥的一部分，然后再加上密钥的剩余部分

定义：仿射加密
> 假设$x, y ,a, b \in Z_26$(26个字母)
>
> 加密：$e_k(x) = y = a \cdot x + b \bmod 26$
>
> 解密：$d_k(y) = x = a^{-1} \cdot (y-b) \bmod 26$
>
> 密钥为：$k = (a, b)$，且满足限制条件gcd(a, 26)=1

gcd(a, 26)=1 这个限制是源于这样一个事实：加密时需要求密钥参数a的逆元。

通过尝试所有$a^{-1}$的可能值，直到$a \cdot a^{-1} = 1 \bmod 26$即可得到逆元

因此仿射加密的确比移位加密复杂，但也是可暴力破解的
$$密钥空间 = (a的可能值) \times (b的可能值)$$


## 序列密码

对称密码学分成分组密码和序列密码两部分
- 序列密码
    - 单独加密每个位
- 分组密码
    - 每次使用相同的密钥加密整个明文位分组


### 序列密码加密与解密

定义：序列密码
> 明文、密文和密钥序列都是由单独的位组成，即$x_i, y_i, s_i \in \{0, 1\}$
> 
> 加密：$y_i = (x_i + s_i) \bmod 2$
> 
> 解密：$x_i = (y_i + s_i) \bmod 2$

加密解密推导：加密和解密用的是相同的函数

$$\begin{aligned}
d(y_i) &= (y_i + s_i) \bmod 2 \\
&= [(x_i + s_i) + s_i] \bmod 2 \\
&= (x_i + 2s_i) \bmod 2 \\
&= (x_i + 0) \bmod 2 \\
&= x_i \bmod 2 \\
\end{aligned}$$

下面给出模2加法的真值表

| $x_i$ | $s_i$ | $y_i = (x_i + s_i) \bmod 2$ |
|-------|-------|-----------------------------|
| 0     | 0     | 0                           |
| 0     | 1     | 1                           |
| 1     | 0     | 1                           |
| 1     | 1     | 0                           |

事实上模2加法与异或XOR是等价的，密文为0或1的概率是完全相等的

密钥序列$s_1, s_2, ...,s_i$是序列密码安全的核心问题，在攻击者看来$s_i$必须的随机的


### 随机数与牢不可破的分组密码

#### 随机数生成器

- 真随机数生成器(TRNG)
    - TRNG的突出特征是它是输出是不可复制的
        - 如拋100次硬币，世界上另一个人抛出和我相同的结果概率很低
    - TRNG都是基于物理过程，主要例子包括抛硬币等
- (通用的)伪随机数生成器(PRNG)
    - PRNG从一个初始种子值开始通过各种计算得到序列
    - PRNG并不是真正意义上的随机，因为它们是可以算出来的
    - 对PRNG的一个一般要求是：必须有良好的统计属性
        - 即它的输出与真随机数序列相同
- 加密安全的伪随机数生成器(CSPRNG)
    - 是一种不可预测的PRNG，即计算后续位在计算上是不可行的


#### 一次一密





