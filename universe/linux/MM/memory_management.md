---
title: Linux中的内存管理
date: 2021-02-09
tags: 
- linux
- mm
- intro
mathjax: true
---

# Linux中的内存管理

## 为何需要逻辑地址

由于系统中的内存是不断在变化的，有时候这个程序使用，有时候那个程序在使用。如果不使用逻辑地址，那当前进程操作的地址被占用，则不能使用内存，因此需要逻辑地址和物理地址之间映射。这样一来进程之间就相互隔离，各自维护自己页表。

那逻辑地址和物理地址是如何映射的？

如果简单的使用偏移量实现：程序A申请前0-199的内存，程序B申请200-299的内存。但程序A的200内存并没有完成使用，大部份是空闲的，将会造成内存浪费。

如果此时程序A释放，程序C想要申请300的内存，但是程序A释放的0-199不足以满足C的要求，C需要寻找更大块的内存，而程序A释放导致的空闲内存一直没被用上，导致浪费。

- 内存碎片
    * 内碎片：申请一段空间，但是没有完全使用，一部分内存的空闲的，造成浪费
        + 用不上
    * 外碎片：申请一段空间，但是前边剩余的一段不满足，需要找后边的大块内存。前边剩余的内存一直用不上操作从浪费
        + 塞不下

因此引入分页机制来优化内存碎片问题


## 分页

分页是将逻辑地址和物理地址切分成很多片，减少了内碎片。逻辑内存中的片叫做页，物理内存中的片叫做页帧(page frame)

而页表就是维护页到页帧映射关系的表。页表主要会存储两个信息：页和其对应的页帧。当然还会存储很多信息，如读写权限，是否可用，是否dirty等。

每个进程都需要维护一个页表

- 页：将逻辑地址划分成若干页面
- 页表项：在页表中一个页号对应的物理块称为一个页表项，页表项的数目等于页面的数目


### 内存映射的过程

如果机器和程序都是32位(2^32这么多的逻辑区间，可以看成以2B为单位，在逻辑中是B为单位，在物理中是以bit为单位)的，并且有256MB内存，页的大小为4k( **注意，这里4k不等于4kb，4k表示的是2^12的逻辑空间，是一个区间，为了说明方便以下每位逻辑空间都称为位，但不是bit的意思** )。看如下逻辑地址：

```
0x000011a3
```

由于每个页大小的4k的，后12位将是空闲的，所有4k对齐需要逻辑上12位的偏移量。因此：

- 逻辑地址32位=20位页号+12位偏移
- 物理地址28位(256MB内存)=16位帧号+12位偏移

从`0x000011a3`可以看出，页号(前20位)为`0x00001`，偏移(后12位)为`0x1a3`

就可以根据页号去寻找帧号了，加入页号和帧号映射关系如下：

| 页号  | 帧号        |
|-------|-------------|
| 00001 | 00f3(16bit) |

就会找到00f3这一帧，然后根据偏移量1a3从这一帧中找到对应地址。

如果对应地址缺页，则会触发缺页中断。进入内核态(异常/中断型)，从磁盘换入或加载内存并填写到内存中，并填写帧号，然后重新进行寻址过程。


## 内存的优化

要真正获取一个内存中的内容实际需要加载两次内存，一次是读取页表，一次是根据页表找到对应内存,因此可以进行时间上的优化。而每个进程都需要维护一个页表，页表本身也是占内存空间的，因此可以进行空间优化。

### 空间优化

分页页占用内存，所以引入多级页表。

如上32位的系统和程序，一个程序要访问所有逻辑空间需要2^20个页面，对应2^20个页表项。如果每个页表项占4B的空间(32bit=4B)，则一个程序维护的页表将占用4MB的物理内存。4MB看起来很小，但是操作系统是要运行很多程序的。

如果使用多级页表，将23位分为4位，4位，12位的分级方式，最后一级指向物理地址。第一级指向第二级，第二级指向第三级。

如果发现第一级只有3项指向第二级，且第二级的都有效，则只需要3\*2^4=48个页表项。


###  时间优化

将最常访问的几个(一般8-128个左右)页表项储存到访问速度更快的硬件中，一般是在MMU，这个小表的名称为**TLB (Translation Lookaside Buffer) **。寻址会先寻找TLB，miss后再查PT。


## 分段

程序内部的内存管理： **分段**。每个段有很多页，页表中存储段号和页号唯一映射物理地址帧号，即通过段号和页找找到唯一映射的帧号。

不过这种段页结合的模式逐渐被淘汰了，即硬件层面的抛弃。但仍然保留了段的概念，只是程序方面便于运算，并不影响分页式内存管理。

```
Kernel Space // 程序间共享

Stack

Libraries

Heap
Data
Text
```



