---
title: linux进程调度机制
date: 2020-11-21
tags: linux, kernel
---

> 看爆！https://zorrozou.github.io/

## 前置

- 进程分类
    * 实时进程(runtime)
        + 跟用户交互需要及时相应
    * 普通进行
        + 不需要那么及时，如编码解码等
    * 对于不同类型的进程应该采用不同的调度方法，实时进程序需要及时响应
- 上下文切换
    * 发生进程调度时，保存当前进程的信息后(如程序计数器，变量，寄存器等context)才能加载另一个进程。这个过程就是上下文切换


## 调度算法

- FIFO
    * 实现简单，但需要等待前面进程执行完才能执行后面的。what if前面是一个要执行很长时间的进程
- STF(Shortest Time First)
    * 整体等待时间下降，但如果是长时间进程先到达时短时间进程还是需要等待

上面的调度算法都是**非抢占**的，一个执行完成才会执行下一个进程，都会导致个别进程需要长时间等待

- STCF(Shortest Time-to-Completion First)，短快优先
    * **会抢占** 。如p1需要100ms，当p1执行了10ms，p2到来只需要10ms，所有会先执行p2，再调度回p1
        + 抢占：一个进程未必执行完才会执行另一个
    * 但这样会执行时间长的进程可能会由于抢占而饥饿
- RR(Round robin)，轮循
    * 每个进程执行一小段时间片然后切换


## 进程队列

- 全局队列
    * 早期多核cpu下使用全局队列保存进程，因此调度时需要加锁，加锁机制导致这种方式性能很低。
- 局部队列
    * 每个cpu有自己的队列，进程在多个队列中负载均衡


## 进程优先级

- 优先级越小优先级越高
    * 用位图表示有优先级时从低到高找(find first)更快
- **nice值**
    * linux中用户可以设置nice值来 **影响优先级** (priority)，范围到`[-20, 19]`
        + `ps -l`，PRI字段可看到优先级，NI字段可看到nice值
    * **nice值越高优先级越低**
        + 简记：表示一个进程对别的进程的nice程度。一个进程对别的进程越好就越不会抢占cpu，得到的时间越少，优先级越低
    * 可以通过`nice`命令设置进程优先级，`renice`命令来修改nice值
- 静态优先级
    * 选择权在用户，用户可以设置nice值来影响优先级
- 动态优先级
    * 选择权在内核，内核根据一些机制调整优先级，如超时的进程会受到降低优先级的惩罚


## linux调度器

- ~~O(n)调度器~~
    * 起初采用线性表遍历寻找最高优先级进程O(n)，效率很低
- O(1)调度器
    * 优先级被映射成一定bitmap，在一个优先级上有进程则对应的bitmap会置1，cpu可以通过位运算快速取出优先级最高的进程
- CFS完全公平调度器
    * 分时间片，每个进程相对公平
    * **virtualtime**，优先级高的进程虚拟时间增长慢，优先级低的进程虚拟时间增长慢
        + 如高优先级进程分到时间片10ms，而虚拟时间1ms
    * 取红黑树中虚拟时间最短(优先级最高)的进程进行调度






