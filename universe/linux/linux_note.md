---
title: Linux学习
date: 2020-1-20
tags: linux
---

## Linux哲学

- Linux基本原则
    * 1. 由目的单一的小程序组成，组合小程序完整复杂任务
    * 2. 一切皆文件
    * 3. 避免捕获用户接口，避免与用户交互
    * 4. 配置文件保存为纯文本格式
- 命令格式`命令 选项 参数`
    * 短选项：`-`加某个字母，如`-h`查看help
        + 短选项可以多个选项写一起`-a -b = -ab`
    * 长选项：`--<option>`
- 命令模板
    * `[]`中表示可选的内容
    * `<>`中表示必须给出的内容
    * `...`表示可以出现多个，可以使用多次
    * 用`|`分割表示多选一，如`[-a|-b]`
- 魔数Magic Number：标记文件的执行格式，如`#!/bin/sh`，也称为shebang


### FHS(文件层级系统)

- /boot: 系统启动相关文件
- /dev: 设备文件
- /etc: 配置文件，存文本
- /home: 用户家目录
- /root: 管理员家目录
- /lib: 库文件
    * /lib/modules: 内核模块文件
    * 静态库
        + linux下表现为.a
    * 动态库:载入到内存中可以复用
        + win下表现为.dll文件，linux下表现为.so(shared object)
- /opt: 可选目录，第三方程序的安装目录
- /proc: 伪文件系统，内核映射
- /sys: 伪文件系统，跟硬件相关的属性映射
- /tmp: 临时文件，会定时清理
- /var: 可变化文件
- /bin: 可执行文件，用户命令
- /sbin: 管理命令
- /usr: universal shared read-only
    * usr下之所以有/usr/bin和/usr/sbin是因为/bin跟启动系统相关，而/usr下跟启动系统后提供正常功能相关
- /usr/local: 又是一个独立的文件系统，也有bin，sbin。是第三方软件的安装路径


## 常用工具

- man：查看手册
    * `whatis name`查看name的目录，使用`man [n] name`打开name第n章
- tr：字符串转换或删除
    * `tr 'a-z' 'A-Z'`把输入中的字符转换成大写
    * `tr -d 'abc'`删除出现的字符，这里是a，b，c
- shell中可以开子shell，使用`pstree`可以查看父子关系，使用exit退出一个
- 环境变量
    * `PATH`命令搜索路径
    * `HISTSIZE`命令历史缓冲区
        + 使用`history`查看命令历史
        + 使用`!n`执行命令历史中第n条历史命令
        + 使用`!-n`执行命令历史中倒数第n条历史命令
        + 使用`!!`执行刚才执行的命令
        + 使用`!string`执行命令历史中最近的以指定字符串开头的命令
        + 使用`!$`引用上一个命令的最后一个参数
- 命令替换：`$(COMMAND)`或使用反引号\`COMMAND\`
    * 把命令的结果放入一个命令中
    * `echo $(ls)`
- **shell中的引号**：
    * 反引号\`\`：命令替换
    * 双引号""：弱引用。可以实现变量替换
    * 单引号''：强引用。不能实现变量替换
- 文件名通配，globbing
    * `*`：任意长度的任意字符
    * `?`：任意单个字符
    * `[]`：指定范围内的任意单个字符
    * `[^]`：指定范围外的任意单个字符
    * 特殊字符，形如`[:punct:]`。`[:punct:]`所有的标点符号


## 管道及IO重定向

- 系统设定
    * 默认输入设备，标准输入，stdin, 0
    * 默认输出设备，标准输出，stdout, 1
    * 标准错误输出，stderr, 2
- 重定向，默认都是重定向标准输入输出
    * 输出重定向
        + `>`覆盖输出
            + 强制覆盖：当设置了不允许覆盖已存在文件时使用`>|`
        + `>>`追加输出
        + `2>`, `2>>`重定向错误输出
            + 可以使用`ls ./ > a.out 2> b.out`这样的形式
        + `&>`重定向标准输出或错误输出到同一个文件
    * 输入重定向
        + `<`输入重定向
        + `<<`Here Document
            ```
            echo << END_SIGN
            > hello
            > END_SIGN
            ```
- 管道
    * `cmd1 | cmd2 `前一个命令的输出作为后一个命令的输入
- tee
    * `man tee`一个输入两个输出


## Shell编程

### 变量

`VARNAME=VALUE`

- 引用：`$VAENAME` or `${VARNAME}`，注意`$()`是引用执行结果，而`{}`才是引用内容
- 环境变量：作用域为当前shell或器子进程
    * 用`export`导出，`export var=value`
- 位置变量
    * `$0, $1, ...`，所有参数，第一个参数...
    * `shift [n]`，把第一个变量弹出。因此有很多变量时可以使用shift
- 特殊变量
    * `$?`，上一个命令的**执行状态**返回值，0正确，1~255执行错误
    * `$#`，参数个数
    * `$*`，参数列表
    * `$@`，参数列表


### 条件判断

``` shell
if expression; then
    statement
elif
    statement
else
    statement
fi
```

- 条件测试的表达式
    * `[ expression ]`， **注意** 中扩号两端的空格是必须的
    * `[[ expression ]]`，两种方法用法相同，但是两个中括号是bash的关键字
    * `test expression`
    * 因为if语句取的是表达式执行状态的结果，所以如果条件判断是命令则不需要中括号，如`if test expression; then`
- shell中进行算数运算
    * **shell把所有的变量都当作字符**，所以要进行算数运算需要额外操作
    * 1. `let`，见`help let`。如`c=$a+$b`
    * 2. `$[expression]`。如`c=$[$a+$b]`
    * 3. `$(())`。如`c=$(($a+$b))`
    * 4. `expr expression`，表达式中，各操作数和操作符直接要有空格，且要使用命令引用。因为本质是调用`expr`程序。如`c=$(expr $a + $b)`
- 退出脚本：`exit`
    * 如果没有指定退出状态，则返回上一条命令的执行状态
    * 0正确，1～255错误
- 文件测试
    * `-e FILE`，是否存在
    * `-f FILE`，是否普通文件
    * `-d FILE`，是否为目录
    * `-r/w/x`，是否可读写执行
