---
title: 操作系统笔记
date: 2021-03-23
tags: 
- OS
mathjax: true
---


## 进程管理

- 并发proc特点
    * 执行顺序不确定
    * todo
- 进程定义
    * todo
- 进程组成
    * 程序段
    * 数据段
    * PCB


### PCB信息

- 标识
    * proc标识
    * 父标识
    * 用户标识
    * 等
- 现场信息
    * reg信息
    * 堆栈指针
    * 等
- 控制信息
    * proc状态
    * 调度信息
    * DS信息
        + 数据结构：如父指针
    * 队列信息
        + pcb地址，如运行队列
    * 位置信息
        + 内存位置
    * 通信信息
        + 消息队列
    * 等



### proc基本状态

最基本的，可细化的状态

- 运行
- 就绪
    * 就绪态不能到等待态，要运行才能控制
- 阻塞(等待)
    * 等待态不能直接到达运行态，要先就绪


- 进程控制语：原语
    * 机器指令构成的程序段的自己，控制proc执行
    * 不可分割

### proc调度

- proc调度时机
    * proc执行完
    * IO等原因
    * 执行某原语
    * 被抢占
    * 时间用完
- proc调度算法
    * todo


### 临界资源

共享资源，但一次应该只能有一个proc使用

- 互斥：对临界资源的竞争
- 同步： 有合作任务的proc直接需要同步，如p2需要p1的结果才能进行，则p1制约p2
- 临界区(Critical Section, CS)
    - 进程中涉及到临界资源的 **程序段** 称为临界区，一次只能有一个proc进入临界区，进程间互斥，退出临界区或换别的proc进入


#### 信号量与PV操作

**信号量(semaphore)** 用于表示资源实体(多少可用)，是与队列有关的整型变量，其取值只能由PV操作改变

```c
struct semaphore{
    int value;   // 表示剩余资源
    Queue queue; // 表示等待队列
};

P(S){
    S.value--;  // 先--才能把要申请资源的proc记录上
    if(S<0) 放队列;
}
V(S){
    S.value++;
    if(P<=0) 唤进程;
}
```

**注意pv操作是先 +- 资源再判断**

- P：申请资源，value-1，减1后value<0，表示资源已被占用，放入等待队列
    * 小于0就记录了有多少想用但没能用，0刚好用完
- V：释放资源，value+1，加1后value<=0，表示有proc在等待队列等待该资源，唤醒一个proc
    * 归还资源后还不大于0，说明还有proc想资源
- 共用sem：常用于实现资源互斥，初值value设为1，有PV操作
- 私用sem：常用于进程间同步，初值设为0或n，一个proc中只有P或V操作，剩下的P或V操作在另一个proc完成

经典同步互斥模型：设进程p1, p2, p3。缓冲区b1, b2，容量都为1，即只能存一份数据。p2需要等待p1将结果写入b1，p3需要等待p2将结果写入b2

```
信号量S1, S2表示缓冲区的读。Sb1, Sb2表示缓冲区的写。Sm1，Sm2表示锁
初值：S1=S2=0, Sb1=Sb2=1, Sm1=Sm2=1

p1          p2          p3
------------ loop -------------
P(Sb1)      P(S1)       P(S2)
P(Sm1)      P(Sm1)      P(Sm2)
写入b1      读b1        读b2
V(Sm1)      V(Sm1)      V(Sm2)
V(S1)       V(Sb1)      V(Sb2)
            P(Sb2)
            P(Sm2)
            写b2
            V(Sm2)
------------ loop -------------
           
p2要等于p1处理的结果，因此p1没处理完时p2申请读缓冲区P(S1)将会进入等待队列
待p1发出可读V(S1)后p2才会执行
p3同理

当p1执行完一个循环，想要执行下一个循环时，如果发现p2还没读取缓冲区数据，则P(Sb1)会让其进入等待队列
```

todo读写者问题


