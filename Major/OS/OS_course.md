---
title: 操作系统笔记
date: 2021-03-23
tags: 
- OS
mathjax: true
---


## 进程管理

- 并发proc特点
    * 执行顺序不确定
    * todo
- 进程定义
    * todo
- 进程组成
    * 程序段
    * 数据段
    * PCB


### PCB信息

- 标识
    * proc标识
    * 父标识
    * 用户标识
    * 等
- 现场信息
    * reg信息
    * 堆栈指针
    * 等
- 控制信息
    * proc状态
    * 调度信息
    * DS信息
        + 数据结构：如父指针
    * 队列信息
        + pcb地址，如运行队列
    * 位置信息
        + 内存位置
    * 通信信息
        + 消息队列
    * 等



### proc基本状态

最基本的，可细化的状态

- 运行
- 就绪
    * 就绪态不能到等待态，要运行才能控制
- 阻塞(等待)
    * 等待态不能直接到达运行态，要先就绪


- 进程控制语：原语
    * 机器指令构成的程序段的自己，控制proc执行
    * 不可分割

### proc调度

- proc调度时机
    * proc执行完
    * IO等原因
    * 执行某原语
    * 被抢占
    * 时间用完
- proc调度算法
    * todo


### 临界资源

共享资源，但一次应该只能有一个proc使用

- 互斥：对临界资源的竞争
- 同步： 有合作任务的proc直接需要同步，如p2需要p1的结果才能进行，则p1制约p2
- 临界区(Critical Section, CS)
    - 进程中涉及到临界资源的 **程序段** 称为临界区，一次只能有一个proc进入临界区，进程间互斥，退出临界区或换别的proc进入


#### 信号量与PV操作

**信号量(semaphore)** 用于表示资源实体(多少可用)，是与队列有关的整型变量，其取值只能由PV操作改变

```c
struct semaphore{
    int value;   // 表示剩余资源
    Queue queue; // 表示等待队列
};

P(S){
    S.value--;  // 先--才能把要申请资源的proc记录上
    if(S<0) 放队列;
}
V(S){
    S.value++;
    if(P<=0) 唤进程;
}
```

**注意pv操作是先 +- 资源再判断**

- P：申请资源，value-1，减1后value<0，表示资源已被占用，放入等待队列
    * 小于0就记录了有多少想用但没能用，0刚好用完
- V：释放资源，value+1，加1后value<=0，表示有proc在等待队列等待该资源，唤醒一个proc
    * 归还资源后还不大于0，说明还有proc想资源
- 共用sem：常用于实现资源互斥，初值value设为1，有PV操作
- 私用sem：常用于进程间同步，初值设为0或n，一个proc中只有P或V操作，剩下的P或V操作在另一个proc完成

经典同步互斥模型：设进程p1, p2, p3。缓冲区b1, b2，容量都为1，即只能存一份数据。p2需要等待p1将结果写入b1，p3需要等待p2将结果写入b2

```
信号量S1, S2表示缓冲区的读。Sb1, Sb2表示缓冲区的写。Sm1，Sm2表示锁
初值：S1=S2=0, Sb1=Sb2=1, Sm1=Sm2=1

p1          p2          p3
------------ loop -------------
P(Sb1)      P(S1)       P(S2)
P(Sm1)      P(Sm1)      P(Sm2)
写入b1      读b1        读b2
V(Sm1)      V(Sm1)      V(Sm2)
V(S1)       V(Sb1)      V(Sb2)
            P(Sb2)
            P(Sm2)
            写b2
            V(Sm2)
------------ loop -------------
           
p2要等于p1处理的结果，因此p1没处理完时p2申请读缓冲区P(S1)将会进入等待队列
待p1发出可读V(S1)后p2才会执行
p3同理

当p1执行完一个循环，想要执行下一个循环时，如果发现p2还没读取缓冲区数据，则P(Sb1)会让其进入等待队列
```

todo读写者问题


#### 管程

为了让开发者在**互斥**逻辑的设计中解脱，引入管程。管程是一种编程语言构件，进入管程的互斥由 **编译器** 负责，用户无需关心如何实现互斥。

- 缺点：
    - 只有几种编程语言支持，兼容性不好
    - 无法解决同步问题


### 进程间相互作用
### 进程通信

- 按数据多少分
    * 低级通信，只传状态或整型数值，信息量少
    * 高级通信，能传大批量数据
- 按通信方式分
    * 直接通信，信息直接给发送方
    * 间接通信，通过接收双方之外的共享结构传递


#### 共享内存

在内存中指定一块区域用来共享存储，各进程可以申请一个存储段，并申请时提交 **关键字** 。系统根据关键字返回，查找/分配，然后将该存储区映射到进程的逻辑空间，此后进程可以直接访问共享内存。

使用共享内存时需要注意同步互斥的问题


#### 消息传递

通过系统的发送(Send)原语和接收(Receive)原语，实现进程间通信。发送原语将消息挂到接收进程的消息队列末尾。接收进程用接收原语从消息队列头取走消息。


#### 信箱

信箱是用来对一定数量的消息进程缓存，每个信箱用标识符区分。一个信箱可以被多个进程共享，实现消息的广播发送。


#### 管道pipe

管道是一种**共享文件** 模式，基于文件系统，以 **先进先出** 的方式实现消息**单向** 传递。

UNIX系统管道的创建通过`pipe()`函数实现。该函数返回分别用于读、写操作的 **文件描述符** `fd[0], fd[1]`。读管道时，利用`fd[0]`文件描述符从管道读取字节，写管道时，利用`fd[1]`向管道写。

```
+----------------------------------+
read(fd[0])    <--      write(fd[1])
+----------------------------------+

读写读写
0是读，1是写
```

- 如果要双向通信需要定义两个管道
- **只适用于父子进程间通信**

观察下面一段程序

```c
int main(){
    char father[] = {"message from father"};
    char child[] = {"message from child"};
    char buff[50];
    int chan1[2], chan2[2];
    int pid;

    pipe(chan1);
    pipe(chan2);
    while((pid=fork())==-1);   // 如果fork返回-1，一直尝试创建，直达创建子进程成功

    if(pid){  // pid>0表示是父进程执行，pid=子进程pid
        close(chan1[0]);
        close(chan2[1]);
        write(chan1[1], father, strlen(father));
        close(chan1[1]);
        read(chan2[0], buff, 50);
        printf("father process: %s\n", buff);
    }else{   // 否则子进程执行
        close(chan1[1]);
        close(chan2[0]);
        read(chan1[0], buff, 50);
        printf("child process: %s\n", buff);
        write(chan2[1], child, strlen(child));
        close(chan2[1]);
    }
}
```

上述程序中，涉及的知识点：

- `fork()`
    * 返回值大于0，表示父进程在执行，返回值为子进程pid
    * 返回值等于0，表示子进程在执行
    * 返回值小于0，表示出错
    * 在fork时子进程会拷贝父进程，拷贝父进程的资源、PCB、状态等
    * 之后再申请资源，都是在各自进程PCB上相互独立的操作
- 父子进程中的`close()`只是关闭了 **当前进程对资源的使用状态**，而不是关闭共享的管道
    * 一旦子进程创建，它就与父进程独立开来了，可以认为状态独立，但是资源 **指向** 的都是同一个，所以是同一个管道，可以用共享资源通信
- 父子进程同步
    * 可以使用`wait()`和`waitfor()`函数，会等待某个子进程终止，然后返回子进程pid


### 线程

如果以进程作为调度的基本单位，则进程间调度的工作量将会很大(如很多资源来回切换)，开销较大。

因此以 **线程** 作为调度的基本单位，调度不再是进程间调度，而是进程内的 **线程间的调度** 。

一个进程内部可以有多个线程，在多线程环境下一个进程打开的资源在 **线程间共享**，使得线程间调度不再不用资源来回切换，只需要记录线程的上下文，大大降低了开销。

> 不同于进程间的共享，进程间共享是生成子进程前的资源共享，生成子进程后各自申请的自己将相互独立。而线程将的资源随时都是共享的。

多线程模型可以看成这么一个结构：

```
# 多线程模型：一个进程中的内容
|-----|
| PCB |
|-----|
同一份资源、状态

|--------------|
| 用户地址空间 |
|--------------|

多个共享
|------------|  |------------|  |------------|
| 线程控制块 |  | 线程控制块 |  | 线程控制块 |
|------------|  |------------|  |------------|
| 用户栈     |  | 用户栈     |  | 用户栈     |
| 核心栈     |  | 核心栈     |  | 核心栈     |
|------------|  |------------|  |------------|
```






















