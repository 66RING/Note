---
title:  自顶向下计算机网络
date: 2020-3-25
---

#  自顶向下计算机网络

## 基本概念

- ISP: Internet Server Provider
- 拓扑：连线的方式
- 吞吐量：水管的大小
- 流量：网速
- 网络大小划分  
	- PAN:personal area network
	- LAN:局域网
	- MAN:城局域网
	- WAN:广局域网
	- 互联网（最大）


### IP地址

IPv4由32个位组成, 通常8个一组如192.168.1.1

前28个位为**网络编号**, 后4位为**主机编号**

**子网掩码**: 子网掩码的1对应网络位的编号, 子网掩码的0对应主机位的编号, 如255.255.255.0
- 作用: 限制广播的网络段, 将莫大的网络划分变小

**子网**表示方法: 网络编号 + 主机号 + / + 子网掩码1的个数
- 如:192.168.1.0/24, 子网掩码为255.255.255.0

**网段地址**: 每个网段的第0个地址
- 如:192.168.1.0. 0 = 0000 0000, 第0号主机

**广播地址**: 网段的最后一个IP地址
- 如:192.168.1.255. 255 = 1111 11111, 最后一个主机


### 路由

路由器的作用是实现跨网段的数据传输和转发, 类似于向导的作用, 这种指引的行为就叫最**路由**


#### 路由表

转发的指南

``` 
再linux下使用: route -n 可以查看路由表
:$ route -n  // 结果有8列
Destination  Gatewaty  Genmask  Flags  Metric  Ref  Use  Iface
```

分别为目的地址, 网关地址, 网关掩码, 最后一列为网卡

Flags带有G的说明是网关规则,
若数据包的目的IP与路由表的目的地址匹配,
路由器会将数据包(通过网卡)转发到Gateway中的网关地址,

如果Flags没有带G, 说明不是网关规则,
目标地址肯定就在本地链路通过用一个交换机相连

通过`traceroute -n IP`可以查看中途经过了哪些路由器

那路由表从何而来呢?
- 直连路由
    - 当主机配置好一个IP后, 会自动生成一个目的地址为该子网的路由
- 手动添加路由(静态路由)
- 通过动态路由协议获取


#### 路由器的功能

- DHCP
    - Dynamic Host Configuration Protocal, 动态主机配置协议
- (S)NAT/DNAT
    - (Source) Network Address Translation
    - 源地址转换NAT功能, 也叫IP伪装
    - 数据包在出路由器前会将数据包的源IP地址转换为路由器WAN口的公网IP地址, 以便被别人找到. 
        - 因为192.168.0.4等是私有的
- DNAT
    - 目的地址转换NAT功能
    - DNAT就是NAT的逆向
    - 实现公网对内部主机的主动访问


#### 路由器的桥接

把路由器的LAN合并到一起, 注意一下关键点
- 在一个LAN中IP地址必须唯一
    - 故从路由的的LAN必须和主路由属于同一网段, 并IP地址唯一
- 在一个LAN中最多有一个DHCP服务器
    - 故要关闭从路由的DHCP功能



## 参考模型  

### 分层原理

信宿机第n层收到的对象应与信源机第n层发出的对象完全一致.
好比做飞机的登机口和下机口

每一层都为他的上一层服务  
信息发送方要做什么:  
- 封装/打包:  
	- 然后从最高层逐层传到物理层
- 每一层上，数据都会被加上头部信息，用于信息传递  

收方要做什么:  
- 解封装/解包  


#### 典型的分层模型:

- ISO OSI 七层模型  
	- 应用层
    - 表示层
    - 会话层
    - 传输层
    - 网络层
    - 数据链路层
    - 物理层
- TCP/IP (DoD) 四层模型  
	- 应用层
    - 传输层
    - 网络互联层
    - 主机到网络层


## 应用层

### 应用程序体系结构

- 客户-服务器体系结构
    - 至少一个服务器主机负责处理多个来自客户主机的请求
- P2P体系结构
    - 主机到主机, 这些主机称为对等方

### 基本概念

- 套接字: socket
    - 进程通过socket的软件接口向网络发送报文和传输报文
        - 好比房子的大门
    - 套接字地址: ip + port
- API: Application Programming Interface

### HTTP

HTTP(HyperText Transfer Protocal, 超文本传输协议)是Web的核心, 客户端和服务器通过交换HTTP报文进行会话. HTTP使用TCP作为它的支撑传输协议, 即先建立TCP连接, 再通过TCP连接向彼此套接字发送报文. 

- TCP为HTTP提供了可靠数据传输服务
    - 即发出的每个请求到能完整的到达目的地
- HTTP是一个无状态协议


- 持续连接的HTTP
    - 可以一个接一个发送请求
- 非持续连接的HTTP
    - 发送一个对象后TCP连接关闭


#### HTTP报文格式

请求报文
- 请求行
    - 方法 URL 版本
    - 包含一系列必要信息
- 首部行
    - 首部字段: 值
    - 相当于指定配置
- 空行
- 实体主体
    - 使用POST方法时才使用

``` 
--- 请求行 ---
GET /some/dir HTTP/1.1
--- 首部行 ---
Host: www.some.com           # 指明对象所在的主机, 该首部行的Web高速缓存所要求的
Connection: close            # 非持续连接
User-agent: Mozilla/5.0      # 发送请求的浏览器类型
# 还会有很多的配置
```

HTTP使用的方法
- GET
- POST
- HEAD
    - 类似GET, 但不返回请求对象
- PUT
    - 允许用户上传对象到指定Web服务器
- DELETE
    - 允许用户删除服务器上的对象

响应报文
- 状态行
    - 版本 状态码 短语
    - 常见状态码
        - 200 请求成功
        - 301 请求的对象已被永久转移
        - 400 Bad Request 请求不能被理解
        - 404 Not Found 请求的文档不在服务器上
        - 505 服务器不支持请求报文的HTTP版本
- 首部行
- 空行
- 实体主体


#### cookie

前面提到HTTP服务器是无状态的, 所以要想内容和用户身份联系起来就要使用cookie.

``` sequence-diagrams
client->server: request
server-->client: response + cookie
client->server: request + cookie
server-->client: response
```


#### Web缓存

Web缓存器也叫代理服务器. Web缓存器既是服务器又是客户端, 它会把请求的结果保存在本地. 在遇到相同的请求是可以由本地数据提供

可以减少网络负担. 如在高速的局域网络架设缓存器

HTTP协议有一种机制, 允许缓冲器证实它的对象是最新的. 这种机制叫做**条件GET**. 使用含有`If-Modified-Since: Date`请求行


### FTP

文件传输协议

区别于HTTP, FTP也运行在TCP上, 但是它使用两个并行的TCP连接来传输文件: 一个是**控制连接**, 一个是**数据连接**.


### 因特网中的电子邮件

由三个部分组成: 用户代理, 邮件服务器, 简单传输协议(SMTP).
邮件通过SMTP在邮件服务器中传递, 在由邮件服务器分发给对应用户.


### DNS

域名系统(Domain Name System, DNS)


#### Host

除了DNS可以解析域名外, Host也能解析域名.
IP信息和域名信息的映射表.
Host映射的优先级要高于DNS.


#### DDNS

动态域名系统(Dynamic Domain Name System). 
其主要作用的动态更新dns服务器上的IP地址.
方便域名与IP的映射.  

可以自己写程序/脚本实现
- 思路1:
    - 调用dns服务商的api实现更新ip地址


## 运输层

运输层协议是在端系统中而不是路由器中实现的. 运输层把应用程序发送的报文转换成运输层分组, 该分组称谓运输层**报文段**.

在发送端系统中, 运输层将这些报文段传递给网络层, 网络层对其封装成网络层分组即(**数据报**)

网络层提供了主机之间的逻辑通信, 而运输层为运行在不同主机上的进程之间提供了逻辑通信.
网络层相当与邮递员负责送到家门口, 分发还得靠运输层, 所以说网络层是运行在主机间, 运输层才是运行在进程间的(端系统), 运输层负责把报文移动到网络边缘(网络层).

- 多路复用
    - 负责收集各个端口的报文, 为每个数据快封装上首部信息后传递到网络层
- 多路分解
    - 运输层负责获取从网络层接收到的报文首部中端口的信息, 并分发到适当的程序中


### 可靠数据传输(RDT)原理

- rdt1.0
    - 停等型
        - 浪费大量时间
    - 通过返回的报文确定是否需要重传
        - 会浪费大量资源重传分组
        - 返回报文也可能有误
- rdt2.0
    - 停等型
    - 肯定回复(ACK)或者否定回复(NAK)负责校验数据是否受损
    - 使用序号的概念,  分分为发送序号和期望序号, 用于检测是否失序
        - 序号可以解决多余的重传
        - 由于期望序号的存在, 也可解决返回报文的差错问题
        - 但接收方没收到会导致等待时间无限增加
- rdt3.0
    - 加入定时器的概念
        - 超时自动重发


#### 流水线可靠数据传输协议

上面提到的协议都是停等型, 性能不能使人满意, 使用窗口/流水线型提高效率

- 流水线
    - 对所有的分组使用序号空间进行编号
        - 序号空间: 如1, 2, 3, 1, 2, 3.序号空间就是1, 2, 3
    - 为什么使用序号空间
        - 报文的比特位是有限的
- 窗口
    - 流水线上一个范围内的分组
    - 为什么使用窗口
        - 报文的比特位是有限的


比较完善的选择重传(SR)协议
    - 校验和
        - 用于检测传输分组中的比特错误
    - 定时器
        - 用于重传丢失的分组
    - 序号
        - 用于检测分组是否失序或冗余
        - 已经接收到的分组可以储存在缓存中, 待顺序恢复后上报
    - 确认/否定确认
        - 接受放通过校验和检测到比特是否出错, 需要回复发送方
    - 窗口/流水线
        - 允许一次发送多个分组
        - 对于SR协议来说, 窗口长度要小于或等于序号空间大小的一半


## 网络层

网络层对运输层发送是分组(数据段)封装成网络层分组, 该分组称为**数据报**.

重要概念
- 转发
    - 涉及分组在单一路由器中一条入链路到一条出链路的传送
- 路由选择
    - 设计所以的路由器经过路由选择协议共同交互, 以决定到达目的地采用的路径


### 网络服务模型

网络层能够提供的某些可能的服务
- 确保交付
    - 确保分组最终将到达目的地
- 具有延时上界的确保交付
- 有序分组交付
- 确保最小带宽
- 确保最大时延抖动
    - 分组间的时延间隔变化不超过某个值
- 安全性服务
    - 数据加密

因特网的网络曾提供了单一的服务: 成为尽力而为服务


#### ATM网络体系结构

ATM网络体系结构提供了多重服务模型, 可以为不同的连接提供不同类型的服务. 其中两个重要的ATM服务模型
- **恒定比特率(CBR)ATM网络服务**
- **可用比特率(ABR)ATM网络服务**


### 虚电路和数据报

网络层提供了主机到主机的连接服务, 或者主机到主机的无连接服务, 而不提供两者. 
仅在网络层提供提供连接服务的计算机网络称为**虚电路(VC)网络**. 
仅在网络层提供提供无连接服务的计算机网络称为**数据报网络**. 


#### 虚电路

虚电路的组成如下:
- 源和目的主机间的路径
- VC号
    - 连着该路径的每段链路的一个号码
- 沿着该路径的每台路由器中转发表的表项
    - 一条虚电路在每条链路上可能具有不同的VC号, 每个中间路由器必须用新的VC号代替每个传输分组的VC号. 
    - 转发表: 当建立连接(虚电路)时增加一项, 终止时删除

一个分组沿其路由在每条链路上不简单保持相同VC号的原因:
- VC字段长度有限
    - 网络有上亿个链路不应一一编码, 浪费资源
- 简化虚电路的建立
    - 每个路由器只用维护自己本地的路由表


#### 数据报网络

在数据报网络中, 每当一个端系统要发送分组, 它就为该分组加上端系统的地址, 然后推进网络中. 
它通过一系列路由传递, 路由器使用其目的地址通过转发表转发. 

数据报网络中的转发表通过路由选择算法进行修改, 通常每1~5分钟更新一次. 
由于转发表随时可能发生变化, 所以一系列分组可能通过不同的路径到达目的, 并可能无序到达.


### 路由器工作原理

输入端口 --> 交换结构(路由选择处理器) --> 输出端口

- 输入端口
    - 将一条输入的物理层链路与路由相连接(一种物理层功能)
    - 需要与位于入链路远端的数据链路层交互(数据链路层功能)
    - 查找功能, 查询转发表决定路由器的输出端口
    - 控制分组从输入端口转发到路由选择器
- 交换结构
    - 路由器内部的一种网络, 连接输入和输出端口
- 输出端口
    - 储存从交换结构接收的分组, 并通过执行必要的链路层和物理层功能在输入链路上(下一个路由器)传输这些分组
- 路由选择处理器
    - 执行路由选择协议, 维护路由表及连接的状态信息, 并为路由器计算转发表

这些功能有时总称为**路由转发平面**


#### 输入端口

输入端口的查找功能能让分组通过交换结构转发到输出端口. 
路由表是由路由选择器计算和更新的, 但会在输入端口保存一份路由表的副本以完成查询功能.
路由表从路由选择器通过独立的总线(如PCI总线)复制到路由卡. 
有了副本, 转发决策能在输入端口进行, 无需调用中央路由选择器, 避免了处理瓶颈. 

查找功能实现的要点:
- 必须使用硬件执行查找
- 需要对大型转发表使用超出简单线性搜索的技术: 快速查找算法
- 注意内存访问的时间

一个分组可能在进入交换结构的时候被暂时阻塞, 这时需要在输入端口处排队. 

输入端口出来要执行重要的查找操作, 还要采用许多其他动作:
- 必须出现物理层和链路层处理
- 必须检查分组的版本号, 检验和以及寿命字段
- 必须更新用于网络管理的计数器


#### 交换结构

交换结构的方式
- 经内存交换
- 经总线交换
- 经互联网络交换


#### 排队处理

在输入端口和输出端口这样的"交叉路口"中会出现排队问题.
随着队伍的增长, 缓存空间最终会耗尽, 导致出现丢包现象. 

缓存设置的经验:
- 少连TCP流时
    - 缓存量等于平均往返延时(RTT)乘链路容量(C)
    - $B = RTT \times C$
- 大量TCP流(N)时
    - $B = RTT \times \frac{C}{\sqrt{N}}$

输出端口出现排队的原因: 假设有N条输入段, N条输出段链路, 每条链路传输速度是一样的.
交换的处理速度是每条链路速度的N被, 则若N条输入最终指向同一输出时, 就会出现阻塞.

输出端口排队的后果是在输出端口上的**分组调度程序**必须选择队列中一个分组进行发送. 
选择的原则可以是:
- 先来先服务(FCFS)
- 加权公平排队(WFQ)

这些分组丢弃与标记的策略叫做**主动队列管理(AQM)**算法.
**随机早期检测(RED)**算法是最广泛研究和实现的AQM算法.

RED算法
- 为输出队列维护一个加权平均值
- 这个平均值小于最小阀值则正在接收
- 这个平均值大于最小阀值小于最大阀值则以某种概率标记或丢弃
- 这个平均值大于最大阀值则标记或丢弃
 
输入端口出现排队的原因: 交换结构不够快. 
因为交换结构一次只能传递一个分组. 
若前方的分组正在排队, 后方分组的出口就算空闲也得等待前方排队完成. 
这种现象叫做输入排队交换机中的**线路前部(HOL)阻塞**.


### 网际协议(IP): 因特网中的转发和编址

因特网的网络层有三个主要组件:
- IP协议
- 路由选择
- 报告数据报中的差错和对某些网络层信息请求进行响应


#### 数据报格式

IPv4中的关键字:
- 版本号
- 首部长度
- 服务类型
- 数据包长度
- 标识, 状态, 片偏移
- 寿命
- 协议
- 首部校验和
- 源和目的的IP地址
- 选项
- 数据(有效载荷)

一条链路层帧能承载的最大数据量叫做**最大传输单元(MTU)**. 
每条链路可能运行具有不同MTU的链路层协议.
当MTU小于数据报长度时, 需要将输出包封装在更小的IP数据报中. 
这些较小的数据包叫做片(fragment)

IPv4设计者将标识, 标志和片偏移字段放在IP数据报首部, 以执行重新组合任务. 
由于IP是一种不靠谱的服务, 数据报可能丢失或失序.
所以需要偏移量来保证顺序, 标志字段来保证完整. 
最后一片标志比特设置为0, 其他片设置为1. 

在目的地, 数据段的有效载荷仅当在IP层已完全重构为初始IP数据报时才被传输到运输层. 
配合TCP就能实现丢包的恢复. 

分片的弊端:
- 有额外的开销
- 让路由器和端系统更复杂
- 能够用于DoS攻击, 攻击者发送一系列古怪的无法预测的片

IPv6从根本上废止了分片.


### IPv4编址

主机与物理链路之间的边界叫做**接口(interface)**, 
路由器与它任意一条链路之间的边界也叫做接口. 
因此IP地址技术上是一个接口相关联的, 而不是主机或路由相关联的. 

IPv4由32个位组成, 通常8个一组如192.168.1.1

前28个位为**网络编号**, 后4位为**主机编号**

**子网掩码**: 子网掩码的1对应网络位的编号, 子网掩码的0对应主机位的编号, 如255.255.255.0
- 作用: 限制广播的网络段, 将莫大的网络划分变小

**子网**表示方法: 网络编号 + 主机号 + / + 子网掩码1的个数
- 如:192.168.1.0/24, 子网掩码为255.255.255.0

**网段地址**: 每个网段的第0个地址
- 如:192.168.1.0. 0 = 0000 0000, 第0号主机

**广播地址**: 网段的最后一个IP地址
- 如:192.168.1.255. 255 = 1111 11111, 最后一个主机

子网的定义:
- 分开主机和路由器的每个接口, 产生几个隔离的网络岛, 使用接口端接这些隔离的网络端点, 这些隔离的网络中没一个叫做一个子网. 

较低阶的比特可能(或可能不)具有另网的子网结构. 


#### IP地址的获取

ISP可能会从已经分配给它的更大快地址中提供一些地址. 
ISP的IP地址又由因特网名字和编号分配机构(ICANN)管理.


## TCP

面向连接的传输

三次握手
- 用户发送特殊的TCP报文
- 服务器用一个特殊的TCP报文回复
    - 两次握手后建立起连接
    - 连接建立后可以互相发送数据
- 最后用户通过第三次报文发送有效载荷


### TCP报文结构

TCP报文段首部包含一下字段:
- 源端口/目的端口
- 校验和
- 32比特的序号字段和确认号字段
- 16比特的接收窗口字段
    - 用于流量控制, 用于指示接收方愿意接受的字节数量
- 可选与变长的选项字段
- 4比特的首部长度字段
    - 因为首部长度是可变的
- 6比特的标志字段
    - ACK比特用于指示字段中的值是否有效
    - RSY, SYN, FIN比特用于连接的建立和拆除
    - URG比特用来指示报文里"紧急"数据
        - 紧急数据的最后一个字节由16比特的**紧急数据指针**字段指出

字段的具体表现
- 最大报文段长度(MSS)
    - TCP从缓存中取出并放入报文段是数据量受MSS限制
    - 应用层数据的最大长度
    - MSS通常由最初确定的由本机发送的最大链路层帧(MTU)长度设置
- 最大传输单元(MTU)
    - 如果链路层协议有1500字节的MTU, 报文首部长40字节, 则MSS长1460字节
- 一个报文的序号
    - 报文段首字节的字节流编号
        - 如一个500 000字节的文件, MSS为1000字节, 第一个首字节编号为0, 第二个为1000...
- 超时间隔计算
    - $TimeoutInterval = EstimatedRTT + 4DevRTT$
    - 每次重传时都会将超时间隔设置为上一个值的两倍
        - 应为有时真的很拥堵
        - 但是也不能这么一直的指数增长
        - 当接受到ACK后重新估计
        - 收到3个冗余ACK后执行快速重传
    - 往返时间(RTT)的估计: $EstimatedRTT = (1 - \alpha)EstimatedRTT + \alpha SampleRTT$
        - $\alpha$通常为0.125
        - 在某个时间会测量一次SampleRTT
    - 波动时间: $DevRTT = (1 - \beta)DevRTT + \beta{|SampleRTT - EstimatedRTT|}$
        - $\beta$通常为0.25
- 流量控制
    - 防止缓冲区溢出
- 拥塞控制
    - 当网络阻塞时遏制网络


#### TCP连接管理

TCP连接管理包括连接的建立和连接的关闭

连接建立的过程
- 1. 客户端向服务发送一个特殊的TCP报文
    - 不包含应用层数据
    - 首部标志位SYN设置为1
    - 客户端还会适当的随机选择一个初始序号(client\_isn), 置于序号字段中
- 2. 服务器回复
    - 服务器收到TCP SYN报文后提取数据, 并为TCP分配缓存和变量
    - 服务器将自己的初始序号(server\_isn)放到报文段中
        - SYN置为1
        - client\_isn + 1
    - 向客户端发送允许连接的报文段
        - 允许连接的报文段有时候被称为**SYNACK报文段**
- 3. 客户端向服务器
    - 客户端也要为连接分配缓存和变量
    - 段对服务器的允许报文进行确认
        - 通过server\_isn + 1放置在报文段中进行确认
        - SYN置为0
    - 可以在报文段中携带客户到服务器的数据

三次握手完成后客户端便可与服务器相互通信. 但是如果只进行了前两次握手, 分配了资源, 但是没有第三次握手就会造成大量资源浪费. **SYN洪泛攻击**就是利用这点. 现在的一种有效的防御系统称为**SYN cookie**

连接关闭
- 客户端向服务器发送
    - 标志位FIN置为1
    - 服务器确认后回复(ACK)
- 服务器向客户端发生它自己的终止报文
    - 标志位FIN置为1
    - 客户端确认后回复(ACK)
- 连接资源释放


#### 拥塞控制的原理

拥塞原因
- 情况1: 两个发送方和一台有无限大缓存的路由器
    - 假设共用的链路吞吐量为R
    - 当两个发送方都以R/2的速率发送时, 速率达到最优
    - 由于共用的吞吐量有限, 当超过R/2时, 排队队列会趋于无限大, 平均排队时间也无限大
- 情况2: 两个发送方和一台有限大缓存的路由器
    - 存在缓存溢出, 溢出部分还得重传
- 情况3: 四个发送方和有无限大缓存的路由器以及多跳路径

拥塞控制的方法
- 端到端拥塞控制
    - 网络层没有提供显示支持
- 网络辅助的拥塞控制
    - 网络层构件(即路由器)向发送方提供拥塞状态的反馈信息(拥塞分组)
        - 可以有路由器直接发给发送方
        - 也可是路由器标记或更新发送发向接受方的分组, 以提示接收方, 再由接收方提示发送方
            - 会多一个完整的往返时间

**网络辅助的拥塞控制例子: ATM ABR拥塞控制**
- 数据中夹杂着所谓的**资源管理信元(RM信元)**
    - 这些信元用来在主机和交换机之间传递拥塞信息
    - 默认32个数据信元中有一个RM信元
- EFCI比特(显示转发拥塞指示)
    - 拥塞的网络交换机可以把数据信元中的EFCI比特设置为1来向主机发送网络已拥塞的信令
    - 如果多数近来收到EFCI为1,则目的地将RM信元的拥塞指示比特(CI比特)设置为1, 并把该信元发送回发送方
- CI和NI比特
    - CI比特是RM信元中拥塞指示(Congestion Indication, CI)比特
    - NI比特是RM信元中的无增长(No Increase)比特
    - 交换机可以在轻微拥塞时将NI比特设置为1, 在严重拥塞时将CI比特设置为1
- ER的设置
    - 每个RM信元还包含一个两字节的显示速率(Explicit Rate, ER)字段
    - 拥塞的交换机也许会降低经过的信元中ER的值


#### TCP拥塞控制

TCP必须使用端到端拥塞控制而不是使用网络辅助拥塞控制, 因为IP层不向端系统提供显示的网络拥塞反馈.
TCP采用的方法是让每个发送方根据所感知的网络拥塞程度来限制其能向连接发送流量的速率.

- 限制流量的方式, 拥塞窗口(congestion window, cwnd)
    - 限制发送流量的速率, 就是流水线的窗口的作用
- 拥塞感知
    - 一个丢失的报文(超时或3个冗余)意味着拥塞
    - 一个确认报文指示能正常接收, 不拥塞
    - 宽带探测, 通过改变速率和检测丢包, ACK来探测
- 速率修改的策略
    - TCP拥塞控制算法
        - 1. 慢启动
        - 2. 拥塞避免
        - 3. 快速恢复
        - 慢启动和拥塞避免是TCP的强制部分

**TCP拥塞控制算法**
- 慢启动
    - 开始时cwnd设置为一个MSS的较小值, 大约为MSS/RTT
    - 如果都是ACK回复, 则一个RTT发送速率就会翻番
    - 指数增长
    - 慢启动结束的第一种标志: 当遇到超时引发的丢包现象时, 将拥塞阀值ssthresh设置为cwnd/2, 然后将cwnd设置为1, 重新开始慢启动
    - 慢启动结束的第二种标志: 达到阀值
    - 慢启动结束的第一种标志: 当遇到3个ACK冗余引发的丢包现象时, 进入快速恢复状态
- 拥塞避免
    - 当cnwd达到阀值ssthresh时, 进入拥塞避免模式, cnwd不再指数增长, 而是每个RTT增加一个MSS
- 快速恢复
    - 很多变种, 不一一陈述, 如冗余丢包后cwnd=ssthresh+1等

TCP拥塞控制常被称为加性增, 乘性减(AIMD)拥塞控制方式


## UDP

无连接传输

优点
- 控制更加精细
    - TCP的拥塞控制机制在链路变得拥塞时来遏制运输层的TCP发送方. 
    - TCP会不惜一切时间代价来确认报文被接收且确认, 对于有最小发送速率要求的应用不友好.
    - 对于不希望过分延时但能容忍一些数据丢失的应用来说是好的
- 无需连接建立
    - TCP需要三次握手, 而UDP不会, 故UDP不会引入建立连接时延
- 无状态连接
    - TCP需要维护连接状态, 接收和发送缓存, 拥塞控制参数以及确认号的参数等等
- 首部开销很小

**UDP提供了差错检测**, 通过在报文中添加校验和(checksum). 校验和工作原理如下

``` 
将报文段中 所有的16比特字的和 进行反码运算, 求和时遇到任何溢出都被回卷.
得到的结果放在报文的校验和字段中. 接收方收到后将所有16比特字和检验和相加应该得到16个1

简单举例: 要三个字段
10011
00111
01111

10011
00111
-------
11010
01111
-------
01001

checksum: 10110 # 和的反码
```
