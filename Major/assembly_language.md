---
title: 汇编语言
date: 2020-5-9
tags: 汇编语言
mathjax: true
---

## 基础知识

- 地址总线
    - CPU通过地址总线来指定存储单元，N根导线可以传送N位二进制数，可选址$2^N$个内存单元，可表示最大的数为$2^N - 1$。
- 数据总线
    - CPU与内存或其他器件之间的数据传输是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传输速度。如8根数据总线一次可以传送8位(一个字节)二进制数据。
- 控制总线
    - CPU对外部器件的控制是通过控制总线来进行的。有多少跟控制总线就意味着CPU提供了对外部器件的多少种控制。
- 主板
    - 主板上有核心器件和一些主要部件，这些部件通过总线(地址总线、数据总线、控制总线)相连
- 接口卡
    - CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作
- 各类储存器芯片
    - 从读写属性上分为两类：随机储存器(RAM)和只读储存器(ROM)
        - 随机储存器可读可写，关机后储存的内容丢失
        - 只读储存器只读不能写入，关机后内容不会丢失
- 地址空间
    - 内存地址空间的大小受CPU地址总线宽度的限制，如CPU地址总线宽度是20,可以传送$2^{20}$个不同的地址信息。可定位$2^20$个内存单元，该CPU的内存地址空间大小为1MB


## 寄存器

寄存器是CPU中程序员可以用指令读写的部件。不同的CPU寄存器的个数、结构是不同的。8086CPU有14个寄存器，每个寄存器有一个名字。这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。


### 通用寄存器

8086CPU的所有寄存器都是16位的，可以储存两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性数据，被称为 **通用寄存器** 。这4个寄存器可以分为两个独立使用的8位寄存器来使用:
- AX可分为AH和AL
    - AX的低8位构成了AL寄存器，高8位构成了AH寄存器，后面的同理
- BX可分为BH和BL
- CX可分为CH和CL
- DX可分为DH和DL


### 几条汇编命令

| 汇编命令  | 控制CPU完成的操作                  | 用高级语言的语法描述 |
|-----------|------------------------------------|----------------------|
| mov ax,18 | 将18送入寄存器AX                   | AX=18                |
| mov ax,bx | 将寄存器bx的数据送入寄存器AX       | AX=BX                |
| add ax,18 | 将寄存器AX的数值加上18             | AX=AX+18             |
| add ax,bx | 将寄存器AX的数值加上寄存器BX的数值 | AX=AX+BX             |


### 物理地址

CPU访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。


### 16位结构的CPU

特征：
- 运算器最多可处理16位的数据
- 寄存器的最大宽度为16
- 寄存器和运算器之间的通路为16位


### 8086CPU给出物理地址的方法

8086CPU有20位地址总线，可以传送20位地址。8086CPU又是16位结构，在内部一次性处理、传输、暂时储存的地址为16位。

8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址

8086CPU读写内存的过程如下：
- 1. CPU中相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址
- 2. 段地址和偏移地址通过内部总线接入一个称为地址加法器的部件
- 3. 地址加法器将两个16位地址合成一个20位的物理地址
- 4. 地址加法器通过内部总线20位物理地址送入输入输出控制电路
- 5. 输入输出控制电路将20位物理地址送上地址总线
- 6. 20位物理地址被地址总线传送到储存器

地址加法器采用 **物理地址=段地址×16+偏移地址** 的方法合成物理地址。如1230+00C8=12300+00C8=123C8(十六进制表示)


### "物理地址=段地址×16+偏移地址"的本质含义

本质含义是：CPU在访问内存时，用一个基础地址(段地址×16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。(有点类似计网中的网段)


### 段的概念

其实内存没有分段，段的划分来自于CPU，如我们可以认为地址10000H~100FFH的内存单元组成一个段，基础地址为10000H，段地址为1000H;我们也可以认为10000H~10007FH、10080H～100FFH的内存单元为两段，基础地址为10000H和10080H，段地址为1000H和1008H。

在编程时根据需要，将若干地址连续的内存单元看作一个段。


### 段寄存器

8086CPU在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。段地址在8086CPU的段寄存器中存放。8086CPU有4个段寄存器：CS、DS、SS、ES。


### CS和IP

CS和IP是8086CPU中最关键的两个寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令指针寄存器。

在8086PC机中，设CS中内容为M，IP中内容为N，8086CPU将从内存M×16+N单元开始，读取一条命令并执行。过程如下

- 1. 8086CPU当前状态：CS中内容为2000H，IP中内容为0000H
- 2. 内存20000H～20009H单元中存放着的机器码对应的汇编指令如下：
    - 地址：20000H～20002H，内容：B8 23 01，长度：3Byte，对应汇编指令：mov ax，0123H
    - 等等
- 3. CS和IP寄存器的内容传入地址加法器合成物理地址20000H
- 4. 输入输出控制电路将物理地址20000H送上地址总线
- 5. 从内存20000H单元开始存放的机器指令B8 23 01通过数据总线送入CPU
- 6. 输入输出控制电路将机器指令B8 23 01送入指令缓冲器
- 7. IP中的值根据指令长度自动增加
- 跳转到第1步，重复这个过程

CPU工作的时候把有的信息看作指令，有的信息看作数据，那CPU根据什么将内容中的信息看着指令？
- CPU将CS:IP指向的内存单元中的内容看作指令，因为，在任何时候，CPU将CS、IP中的内容看作指令的段地址和偏移地址，来在内存中读取指令码


### 修改CS、IP的指令

在CPU中程序员能用指令读写的部件只有寄存器，程序员可以通过寄存器实现对CPU的控制。CPU从何处执行指令是由CS、IP中的内容决定的，通过改变CS、IP中的内容来控制CPU执行目前指令。

8086CPU大部分寄存器的值都可以通过mov指令来改变，mov指令被称为传送指令。但mov指令不能用于设置CS、IP的值，因为8086没有提供这样的功能。要改变CS、IP的内容需要的指令被称为跳转指令。一下简单介绍jmp指令。

若想修改CS、IP的内容，可用`jmp 段地址:偏移地址`的指令完成，如`jmp 2AE3:3`执行后`CS=2AE3H, IP=0003H`。

若想仅修改IP的内容，可用形如`jmp 某一合法寄存器`的指令来完成，如`jmp ax`执行后`IP=ax`。含义上好似`mov IP,ax`


## 寄存器(内存访问)

### 内存中字的储存

**字单元的概念** :字单元，即存放一个字型数据(16位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。

以后我们称起始地址为N的字单元简称为N地址字单元。

例子：
|   |     |
|---|-----|
| 0 | 20H |
| 1 | 4EH |
| 2 | 12H |
| 3 | 00H |

0地址单元中存放的字节型数据是：20H

0地址字单元中存放的字型数据是：4E20H


### DS和[address]

CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。8086CPU中有一个DS寄存器，通常用来存放要访问数据的段地址。

`mov al, [0]`，这个指令将内存单元中的内容送入寄存器al。"[address]"表示一个内存单元，其中`[0]`中的0表示内存单元的偏移地址。执行命令时8086CPU自动读取DS中的数据为内存单元的段地址。

如何把一个数据送入DS寄存器呢？我们以前用过类似`mov ax,a`这样的指令来完成，但是8086CPU不支持将数据直接放入段寄存器的操作，所有需要先将数据放入一个一般寄存器，然后把一般寄存器的内容送入DS寄存器，`mov ds,ax`。


### 字的传送

我们用mov指令在寄存器和内存之间进行字节型数据的传送。因为8086CPU是16位结构的，也就是说一次传送一个字。只要在mov指令中给出16位寄存器就可以进行16位的数据传送了，mov指令中给出8位寄存器就进行8位数据传输。

例子：
|   |     |
|---|-----|
| 0 | 20H |
| 1 | 4EH |
| 2 | 12H |
| 3 | 00H |

`mov ax,[1]`的结果是`ax=124EH`


### CPU提供的栈机制

8086CPU提供相关的指令来以栈的方式访问内存空间，这意味着基于8086编程时，可以将一段内存当作栈来使用。

8086CPU提供`push`和`pop`的入栈和出栈指令。`push ax`表示将寄存器ax中的数据送入栈中，`pop ax`表示从栈顶取出数据送入ax。8086CPU的入栈和出栈操作都是以字为单位进行的。

- CPU如何知道哪段地址空间被当作栈来使用？push和pop时如何知道哪个单元是栈顶单元？
    - 8086CPU中，有两个寄存器，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。**任意时刻SS:SP指向栈顶元素** 。

`push ax`执行时，由一下两个两步完成
- 1. SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶单元为新的栈顶
- 2. 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶

因为CPU执行顺序是从地址低到高，而栈的后进先出的结构，所以push时从后方的地址开始
|                |    |
|----------------|----|
| 10000H         |    |
| 10001H         |    |
| ...            |    |
| SS:SP\->1000EH | 23 |
| 1000FH         | 01 |

`pop ax`的执行过程和`push ax`刚好相反：
- 1. 将SS:SP指向的内存单元处的数据送入ax中
- 2. SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新栈顶

栈为空时，偏移地址的计算方法：最底部的字单元的偏移地址+2，如：
|                        |  |
|------------------------|--|
| 10000H                 |  |
| 10001H                 |  |
| ...                    |  |
| (最底部的字单元)1000EH |  |
| 1000FH                 |  |
| SP=0010H               |  |


### 栈段

将一段内存当作栈段仅仅是我们编程时的一种安排


### 小结

- 字在内存中存储时，要用两个地址连续的内存单元来存放
- 用mov指令访问内存单元，可以在mov指令中给出内存单元的偏移地址，此时段地址默认在DS寄存器中
- [address]表示一个偏移地址为address的内存单元
- 在内存和寄存器之间传送数据类型时，高地址单元和高8位寄存器、低地址单元个低8位寄存器相对应
- mov、add、sub是具有两个操作对象的指令，jmp是具有一个操作对象的指令
- CPU不提供栈顶越界的保护，我们要自己注意


## 一个程序

### 一个源程序从写出到执行的过程

- 编写汇编源程序
    - 产生一个储存源程序的文本文件
- 对源程序进行编译链接
    - 使用编译程序对源程序进行编译生成目标文件，再用链接工具对目标文件进行链接，生成可在操作系统中直接运行的可执行文件
- 执行


### 源程序

#### 伪命令

在汇编语言源程序中，包含两种命令，一种是汇编指令，一种是伪指令。
- 汇编指令是有对应机械码的指令，可以被编译为机械指令，最终被CPU执行
- 伪指令没有对应的机械码，最终不被CPU执行
    - 伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作

##### segment和ends

segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时必须要用的一对为指令。segment和ends的功能是定义一个段，一个段必须有一个名称来标识，格式为：

``` 
段名 segment
    ...
段名 ends
```

一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。一个程序中所有将被计算机所处理的信息：指令、数据、栈，被划分到不同的段中。

##### end

end是一个汇编程序的结束标记，如果碰到了伪指令end，就结束对 **源程序** 的编译。所以我们在写程序的时候，如果程序写完了，要在结尾出加上伪指令end。否则编译器无法知道何时结束。

注意，不要搞混end和ends，ends是和segment成对使用的，标记一个段的结束。而end是标记整个程序的结束。

##### assume

这个为指令含义为"假设"，它假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联。通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。

如下就是将一个把一个叫做code的段和cs段寄存器联系起来:

``` 
assume cs:code

code segment
    ...
code ends
```

#### 源程序中的"程序"

程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机械码，储存在可执行文件中


#### 程序返回

一个程序结束后，将CPU的控制权交还给使它得以运行的程序，我们称这个过程为：程序返回。

在程序末尾使用两条指令可以实现程序返回：

``` 
mov ax,4c00H
int 21h
```


## [BX]和loop命令

- 用[address]表示一个内存单元时，单元的长度(类型)可以由具体指令中的其他操作对象(比如说寄存器)指出，如`mov al,[0]`这个内存单元就是一字节
- [bx]同样也表示一个内存单元，它的偏移地址在bx中
- loop进行循环
- 约定符号idata表示常量
- 我们将使用符号"()"来表示一个寄存器或一个内存单元中的内容


### [BX]

看看如下命令的功能

``` 
mov ax,[bx]
```

功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA中的数据送入ax，即:(ax)=((ds)\*16+(bx))

值得注意的是，bx是寄存器，可以使用一些指令，如：`inc bx`。就可以方便的完成某些任务，如：把每个内存单元的内容变为1。


### Loop指令

loop指令的格式是：loop标号，CPU执行loop指令的时候，要进行两部操作：1. (cx)=(cx)-1; 2. 判断cx中的值，不为零则跳转至标号处执行程序，否则向下执行。

可以看到cx中的值影响着loop指令的结果，通常我们在cx中存放循环次数

例：计算2^12。(N\*2=N+N)

``` 
assume cs:code
code segment
    mov ax,2
    mov cx,11
s:  add ax,ax
    loop s
    mov ax,4c00H
    int 21h
code ends
end
```

执行loop时(cx)先减1,然后若(cx)不为0，则跳转到s处。从上面的例子可以总结出用cx和loop配合实现循环的3个要点：
- 1. 在cx中存放循环次数
- 2. loop指令中的标号所标识地址要在前面
- 3. 要循环的程序段，要写在标号和loop指令中间

用cx和loop指令配合的框架如下：

``` 
    mov cx,循环次数
s:
    循环执行的程序段
    loop s
```


### loop和[bx]的联合应用

若我们想要计算ffff:0~ffff:b单元中的元素的和，结果储存在dx中，分析：

- 1. dx是16位的寄存器，内存单元不能直接加到dx中，因为如果直接加会自动区一个字的大小，不满足题意
- 2. 不能用dl来做累加操作，因为dl大小不足以容纳所有内存单元的和导致进位丢失

所以我们需要引入一个16位寄存器ax作为中介，先把内存单元的内容送如al，在用ax和dx相加，通过bx和loop就可以完成。


### 段前缀

段地址默认在ds中，我们可以在访问的内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。如：`mov ax,ds:[bx]`


### 一段安全的空间

任意向一段内存空间写入内容是很危险的，因为这段内存空间可能存放着系统数据或代码。


## 包含多个段的程序

程序取得所需空间的方法有两种，一种是加载程序的时候为程序分配，另一种是程序在执行的过程中向系统申请。我们将介绍第一种。

我们若要一个程序在被加载的时候取得所需的空间，则必须要在源程序中做出说明。


### 在代码段中使用数据

考虑这样一个问题，编程计算一下8个数据的和，结果存在ax寄存器中：2134h、5342h、6563h、...。如何将这些数据储存在一组地址连续的内存单元中？又在哪找到这段内存空间？

我们可以在程序中，定义我们希望处理的数据，这些数据会被编译、连接程序作为程序的一部分写到可执行文件中。当可执行文件中的程序被加载入内存时，这些数据也会被加载如内存中。这些数据自然而然地获得了储存空间。

具体看下面的例子

``` 
assume cs:code

code segment
    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422

    mov ax,2345h
    some code...
code ends
end
```

程序开头"dw"的含义是定义字型数据(define word)。那这些个数据在哪里呢？由于它们在代码段中，程序在运行的时候CS中存放代码段的地址，所以可以从CS中的到他们的段地址。那它们的偏移地址是多少？因为用dw定义的数据处于代码最开始，所以偏远地址为0～E。

但是编译、连接成可执行文件后，在系统直接运行可能出现问题，因为在程序的入口处不是我们希望执行的指令(而是一些数据)。因此，我们可以在源程序中指明程序的入口所在：

``` 
assume cs:code

code segment
    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422

    start:  mov ax,2345h   ; <---- 在程序的第一条指令的前面加上标号start

            some code...
code ends
end start       ; <---- 

```

在程序的第一条指令的前面加上标号start，这个标号在伪命令end的后面出现，用于通知编译器程序的入口在什么地方。

回顾可执行文件中的程序执行过程如下：
- 1. 有其他的程序(shell等)将可执行文件中的程序加载入内存
- 2. 设置CS:IP指向程序的第一条要执行的指令(程序入口)，从而使程序得以运行
- 3. 程序结束后，返回到加载者

现在问题是，根据什么设置CPU的CS:IP指向程序的第一条要执行的指令？这一点，是由可执行文件中的描述信息指明的。可执行文件由描述信息和程序组成：程序来自源程序中的汇编指令和定义的数据;描述信息则主要是通过编译、连接程序对源程序中相关的伪指令进行处理所得到的信息。


### 在代码段中使用栈

我们首先要有一段可当作栈的空间，可在程序中通过定义数据来获取一段空间，然后将这段空间当作栈空间来使用：

``` 
assume cs:code

code segment
    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422
    dw 0,0,0,0,0,0,0,0
                            ;用dw定义8个字型数据，加载程序后将获得8个字的内存空间，这段空间可当作栈使用

    start:      mov ax,cs
                mov ss,ax
                mov sp,20h  ;将栈顶ss:sp指向cs:20h
                
                some code...
code ends
end
```

这段程序中定义了8个字型数据，它们的值都是0。这8个数据的值是多少对程序来说没有意义，只是用它们来开辟内存。


### 将数据、代码、栈放入不同的段

我们在编程的时候要主要何处是数据，何处是代码，何处是栈。这样显然就有两个问题：
- 把它们放在一个段中使程序显得混乱
- 一个段的容量是受限的，如果数据、栈和代码都放在一个段中，空间可能就不够

所以用多个段来存放数据、代码和栈。我们用定义代码段一样的方法定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来获取栈空间。如下：

``` 
assume cs:code,ds:data,ss:stack

data segment
    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422
data ends

stack segment
    dw 0,0,0,0,0,0,0,0
stack ends

code segment
start:  mov ax,stack
        mov ss,ax
        mov sp,20h  ;设置栈顶ss:sp指向stack:20
        ...
code ends

end start

```

- 定义了多个段方法
    - 对于不同的段，要用不同的段名
- 对段地址引用
    - 段名就相当于一个符号，它代表这段地址


## 更灵活的定位内存地址的方法

### and和or指令

- and指令：逻辑与指令，按位进行运算
    - 通过该指令可将操作对象相应位设备0，其他位不变
- or指令：逻辑或指令，按位进行运算
    - 通过该指令可将操作对象相应位设备1，其他位不变


### 以字符形式给出的数据

可以在汇编程序中，用'...'的方式指明数据是以字符的形式给出的，编译器将它们转化成对应的ASCII码。如

``` 
assume cs:code
data segment
    db 'unIX'  ;; db是define binary，用一个字节储存，与dw同理
data ends
end
```

"db 'unIX'"就相当于"db 75H, 6EH, 49H, 58H"


### 大小写转换的问题

常规的解法是ASCII码加上或减去一个数，但是我们还没说到条件控制，该怎么办呢？寻找新的规律可以看到，就ASCII码的二进制形式来看，除了第5位外，大写字母和小写字母的其他位都一样。因此我们要了新的方法：将第5位变为0或1就能改变成大小写了。


### 用[bx+idata]的方式进行数组的处理

我们知道在C语言中，数组实际上就是一段连续的内存空间。假设第一个数长5个字节，第二个数组有5个字节：

``` 
mov al,[bx]  ;; 定位第一个数组
mov al,[5+bx]  ;; 定位第二个数组
;;或写成
mov al,5[bx]
```

和C语言对比：
- C语言
    - `a[i], b[i]`
- 汇编语言
    - `0[bx], 5[bx]`


### SI和DI

si和di是8086CPU中和bx功能近似的寄存器，si和di不能分成两个8位寄存器来使用。

我们可以灵活使用[bx+si+idata]和[bx+di+idata]来表示一个内存单元。

-对于[bx+si]和[bx+di]，有指令`mov ax,[bx+si]`等，该指令也可以写出如下格式(常用)
    - `mov ax,[bx][si]`
-对于[bx+si+idata]和[bx+di+idata]，有指令`mov ax,[bx+si+200]`等，该指令也可以写出如下格式(常用)
    - `mov ax,200[bx][si]`
    - `mov ax,[bx][si].200`
    - `mov ax,[bx].200[si]`


## 数据处理的两个基本问题

- 1. 处理的数据在什么地方?
- 2. 要处理的数据有多长?

我们定义两个描述性符号：reg和sreg。reg表示寄存器;sreg表示段寄存器。


### bx、si、di和dp

前面三个寄存器已经讲过，现在来进行一下总结：
- 1. 在8086CPU中，只有这4个寄存器可以用在[...]中来进行内存单元的寻址
- 2. 在[...]中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si、bx和di、bp和si、bp和di
- 3. 只要在[...]中使用寄存器bp，而指令没有显性地给出段地址，段地址默认在ss中


### 汇编语言中数据位置的表达

汇编语言中用3个概念来表达数据的位置：
- 立即数(idata)
    - 对于直接包含在机器指令中的数据(执行前在CPU的指令缓冲器中)，在汇编语言中称为：立即数，在汇编指令中直接给出
- 寄存器
    - 指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名
- 段寄存器(SA)和偏移地址(EA)
    - 指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中(如ds)
 

### 指令要处理的数据有多长

8086CPU的指令，可以处理两种尺寸的数据：byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。汇编语言用以下方法处理：
- 根据寄存器名指明要处理的数据的尺寸
- 在没有寄存器名存在的情况下，用操作符`X ptr`指明内存单元的长度，X在汇编指令中可以为word或byte
    - 如：`mov word ptr ds:[0],1`
- 其他方法
    - 这些指令默认了访问的是字单元还是字节单元，如`push [1000H]`push指令只进行字操作


### div指令

div是除法指令，使用div做除法时应注意以下问题：
- 除数：有8位和16位两种，在一个reg或内存单元中
- 被除数：默认放在AX或DX和AX中
    - 如果除数是8位，被除数则为16位，默认在AX中存放
    - 如果除数是16位，被除数则为32位，默认在DX和AX中存放，DX存放高16位，AX存放低16位
- 结果
    - 如果除数为8位，则AL储存除法操作的商，AH储存除法操作的余数
    - 如果除数为16位，则AX储存除法操作的商，DX储存除法操作的余数

格式如下：

```
div reg
div 内存单元
```

例：计算100001/100

被除数100001远大于65535，所以只能用dx和ax两个寄存器联合存放100001(32位)。除数小于255,可以在一个8位寄存器中存放。但是因为被除数是32位的，除数应该为16位，所以用一个16位的寄存器储存100.

``` 
mov dx,1
mov ax,86A1H
mov bx,100
div bx
```


### 伪指令dd

dd是用来定义dword(double word，双字)类型数据的


### dup

dup是一个操作符，在汇编语言中和db、dw、dd等一样，也是由编译器识别处理的符号。它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。如：

``` 
db 3 dup (0,1,2)
```

定义了9个字节，相当于`db 0,1,2,0,1,2,0,1,2`

dup的使用格式如下：
- db 重复的次数 dup (重复的字节型数据)
- dw 重复的次数 dup (重复的字型数据)
- dd 重复的次数 dup (重复的双字型数据)














