---
title: 操作系统
date: 2020-6-12
tags: 计算机,操作系统
---


## 概述

shell对外暴露的接口，操作系统对外提供服务

特征
- 并发
    - 同时存在多个运行的程序
- 共享
    - 操作系统控制如何"同时"访问
    - 文件互斥
- 虚拟
    - 让每个用户/程序都觉得有一个计算机专门为它提供服务
- 异步
    - 程序执行不是一贯到底的，向前推进的速度有系统调度
    - 但是只要环境相同，每次运行的结果一定相同
- 相互联系也相互区别


- Microkernel:微内核架构设计
    - 只放基本的功能
    - 文件管理、网路协议栈等都是放在外围以服务的形式存在，服务和服务之间通过内核的消息传递机制
    - 相互隔离，很灵活，小巧
    - 代价就是性能
- 外核设计
    - 内核分成两块，
        - Exokernel(外核)与硬件打交道：完成硬件功能的复制。
        - 建立在exokernel之上，跟具体应用打交道，再通过它访问exokernel，来访问硬件
            - 可对应用进行相应的设计，使得速度更快
            - 完成应用隔离
- 虚拟机
    

## Part 2

- 计算机启动

os存放在硬盘中，需要bootload将它放入内存。bootloader又由bios负责放入内存。
- bios提供各种支持：检测外设，初始化检查，把bootloader放入内存，让它执行
- bootloader：加载os，从硬盘到内存


应用间接与外设打交道，之所以应用不能直接访问外设是因为应用是不可信任的，而操作系统是可信任的;另一方面操作系统外为上层提供一致的接口，使得上层应用不用关注底层细节，通用可移植，提高效率。由此设计一下三个基本概念

- 三个基本概念
    - 中断
        - 产生的源头：外设产生
        - 处理的时间:异步事件，不会知道什么时候产生
        - 响应：持续，对应用程序是透明的
    - 异常
        - 产生的源头：应用意想不到的行为
        - 处理的时间：同步，一定在某个特定的指令可以产生，可以确定时间
        - 响应：杀死或重新执行
    - 系统调用
        - 产生的源头：应用请求操作系统提供服务
        - 处理的时间：同步或异步(返回点有可能是异步的)
        - 响应：等待和持续

- 中断和异常的处理过程
    - 中断码
        - 查表
    - 保存和恢复
        - 程序执行过程中被中断，需要保存当前处理状态，便于恢复后继续执行
- 异常处理过程
    - 保存现场
    - 异常处理
        - 异常编号，相应处理
    - 恢复现场
- 系统调用过程
    - 访问系统调用接口
    - 用户态切到内核态，控制权交给操作系统
        - 用户态：可执行权限低
        - 内核态：可执行任何指令
    - 处理完成后返回成功失败


## Part 3

### 计算机体系结构及内存分层体系

...


### 地址空间与地址生成

- 地址空间
    - 物理地址空间
        - 硬件支持的地址空间
    - 逻辑地址空间
        - 一个运行打程序所拥有的内存范围
- 地址空间生成
    - cpu会根据逻辑地址查找物理地址，对应对应关系储存在MMU的表示映射关系的区域
    - CPU执行某条指令时，ALU根据指令的内容发送请求，携带逻辑地址。CPU中的MMU查找MMU对应的物理地址
    - 逻辑地址和物理地址的联系又操作系统生成
- 检查地址的安全
    - 确保每个程序访问的地址空间


### 连续内存分配：内存碎片与分区的动态分配

- 外碎片
    - 分配单元之间的未使用内存
- 内碎片
    - 在分配单元中的碎片

- 简单的内存管理方法
    - 当一个程序准许运行在内存中时，分配一个连续的区间
    - 分配一个连续的内存区间给运行的程序以访问数据
- 分配策略
    - 首次适配算法
        - 碰到的第一个能够满足需求的空闲块，分配给程序
        - 需求
            - 按照地址排序的空闲地址块列表
            - 重新分配需要检查，看是否有空闲块能够合并
        - 优势
            - 简单
            - 易于把大的空闲块留在结尾
        - 劣势
            - 容易产生外碎片
            - 不确定性
    - 最优适配算法
        - 寻找最适合的空闲块
        - 需求
            - 按照大小排序的空闲地址块列表
            - 重新分配需要检查，看是否有空闲块能够合并
        - 优势
            - 避免了把大的空闲块拆散
            - 最小化外部碎片的产生
            - 比较简单
        - 劣势
            - 重新分配慢
            - 外碎片拆得很细，使得将来的利用可能性小
            - 易产生很多没用的小碎片
    - 最差适配算法
        - 与最优相反，找差距最大的空闲块
        - 需求
            - 按照大小排序的空闲地址块列表
            - 重新分配需要检查，看是否有空闲块能够合并
        - 优势
            - 分配时中等尺寸时效果最小
        - 劣势
            - 易于破碎大的空间，以致于(将来需要时)大分区无法被分配
            - 重新分配慢


### 连续内存分配：压缩式与交换式碎片整理

- 压缩式碎片整理
    - 重置程序以合并孔洞
    - 要求所有程序是动态可重置的
    - 思考：
        - 何时重置
        - 开销
- 交换式碎片整理(swaping)
    - 运行程序需要更多的内存
    - 把硬盘当作内存的备份(虚拟内存)，将等待需求较长的程序挪到硬盘腾出内存
    - 抢占等待的程序&回收他们的内存
    - 思考
        - 那些程序交换
        - 何时换入换出


## Part 4

### 非连续内存分配：分段

- 连续内存分配的缺点
    - 分配给一个程序的物理内存是连续的
    - 内存利用率低
    - 有外碎片和内碎片的问题
- 为什么需要非连续内存分配(优点)
    - 一个程序的物理地址空间是非连续的
    - 更好的内存利用和管理
    - 允许共享代码和数据
    - 支持动态加载和动态链接
- 非连续分配的缺点
    - 管理开销：如何建立虚拟地址和物理地址之间的转换
        - 软件方案
        - 硬件方案
            - 分段
            - 分页

- 分段
    - 段访问机制
        - 程序访问内存需要一个二维数组(段号s，段内偏移addr)
    - 分段的寻址方案
        - 虚拟内存通过某种映射联系到物理地址
        - 需要一个段表，操作系统建立
        - 需要直到段的大小，防止偏移地址超出范围


### 非连续内存分配：页表

页表其实就是一个大数组，每个运行的程序都有一个页表，每个页表有(page num, offset)
- 属于程序运行状态，会动态变化
- PIBR：页表基址寄存器
- 页表内容
    - Flag标志位
        - dirty bit：是否合法
        - resident bit：物理地址中是否存在
        - clock/reference bit
    - 帧号frame num：f
- CPU通过页号和偏移寻址到对应的页表项，把帧号和偏移组合形成物理地址

- 分页机制的性能问题：
    - 访问一个内存单元需要两次内存地址访问
        - 一次获取表项
        - 一次访问数据
    - 页表可能很大，而且为了隔离每个程序要有自己的页表
    - 页表空间大，因此访问效率页会有问题
- 解决办法
    - 缓存近期访问的页帧转换表项(TLB)
        - TLB使用关联内存实现，具备快速访问性能
        - 如果TLB命中，物理页号可以很快获取
        - 如果TLB未命中TLB miss，对应的表项被更新到TLB中
            - 多数编程(访问)的局部性可以降低TLB miss
    - 间接访问


### 非连续内存分配：页表-二级、多级页表

速度问题解决了，空间上如何解决？那就需要页表分级

以二级页表举例，把一块大的页表分成两块，把大的page num分成两块：p1、p2。
通过一级表[p1]找到二级表的地址，在用二级表地址做索引，二级表[p2]找到frame num就可以找到物理地址。

整个过程多了寻址，导致开销增大，但是通过分级，当物理地址不存在时(在一级表就可以得出)，从而二级表不必保存这部分内容。以时间换空间。
    
多级页表同理


### 非连续内存分配：页表-反向页表

?rebuild?


## 






