---
title: 操作系统
date: 2020-6-12
tags: 计算机,操作系统
---


## 概述

shell对外暴露的接口，操作系统对外提供服务

特征
- 并发
    - 同时存在多个运行的程序
- 共享
    - 操作系统控制如何"同时"访问
    - 文件互斥
- 虚拟
    - 让每个用户/程序都觉得有一个计算机专门为它提供服务
- 异步
    - 程序执行不是一贯到底的，向前推进的速度有系统调度
    - 但是只要环境相同，每次运行的结果一定相同
- 相互联系也相互区别


- Microkernel:微内核架构设计
    - 只放基本的功能
    - 文件管理、网路协议栈等都是放在外围以服务的形式存在，服务和服务之间通过内核的消息传递机制
    - 相互隔离，很灵活，小巧
    - 代价就是性能
- 外核设计
    - 内核分成两块，
        - Exokernel(外核)与硬件打交道：完成硬件功能的复制。
        - 建立在exokernel之上，跟具体应用打交道，再通过它访问exokernel，来访问硬件
            - 可对应用进行相应的设计，使得速度更快
            - 完成应用隔离
- 虚拟机
    

## Part 2

- 计算机启动

os存放在硬盘中，需要bootload将它放入内存。bootloader又由bios负责放入内存。
- bios提供各种支持：检测外设，初始化检查，把bootloader放入内存，让它执行
- bootloader：加载os，从硬盘到内存


应用间接与外设打交道，之所以应用不能直接访问外设是因为应用是不可信任的，而操作系统是可信任的;另一方面操作系统外为上层提供一致的接口，使得上层应用不用关注底层细节，通用可移植，提高效率。由此设计一下三个基本概念

- 三个基本概念
    - 中断
        - 产生的源头：外设产生
        - 处理的时间:异步事件，不会知道什么时候产生
        - 响应：持续，对应用程序是透明的
    - 异常
        - 产生的源头：应用意想不到的行为
        - 处理的时间：同步，一定在某个特定的指令可以产生，可以确定时间
        - 响应：杀死或重新执行
    - 系统调用
        - 产生的源头：应用请求操作系统提供服务
        - 处理的时间：同步或异步(返回点有可能是异步的)
        - 响应：等待和持续

- 中断和异常的处理过程
    - 中断码
        - 查表
    - 保存和恢复
        - 程序执行过程中被中断，需要保存当前处理状态，便于恢复后继续执行
- 异常处理过程
    - 保存现场
    - 异常处理
        - 异常编号，相应处理
    - 恢复现场
- 系统调用过程
    - 访问系统调用接口
    - 用户态切到内核态，控制权交给操作系统
        - 用户态：可执行权限低
        - 内核态：可执行任何指令
    - 处理完成后返回成功失败


## Part 3

### 计算机体系结构及内存分层体系

...


### 地址空间与地址生成

- 地址空间
    - 物理地址空间
        - 硬件支持的地址空间
    - 逻辑地址空间
        - 一个运行打程序所拥有的内存范围
- 地址空间生成
    - cpu会根据逻辑地址查找物理地址，对应对应关系储存在MMU的表示映射关系的区域
    - CPU执行某条指令时，ALU根据指令的内容发送请求，携带逻辑地址。CPU中的MMU查找MMU对应的物理地址
    - 逻辑地址和物理地址的联系又操作系统生成
- 检查地址的安全
    - 确保每个程序访问的地址空间


### 连续内存分配：内存碎片与分区的动态分配

- 外碎片
    - 分配单元之间的未使用内存
- 内碎片
    - 在分配单元中的碎片

- 简单的内存管理方法
    - 当一个程序准许运行在内存中时，分配一个连续的区间
    - 分配一个连续的内存区间给运行的程序以访问数据
- 分配策略
    - 首次适配算法
        - 碰到的第一个能够满足需求的空闲块，分配给程序
        - 需求
            - 按照地址排序的空闲地址块列表
            - 重新分配需要检查，看是否有空闲块能够合并
        - 优势
            - 简单
            - 易于把大的空闲块留在结尾
        - 劣势
            - 容易产生外碎片
            - 不确定性
    - 最优适配算法
        - 寻找最适合的空闲块
        - 需求
            - 按照大小排序的空闲地址块列表
            - 重新分配需要检查，看是否有空闲块能够合并
        - 优势
            - 避免了把大的空闲块拆散
            - 最小化外部碎片的产生
            - 比较简单
        - 劣势
            - 重新分配慢
            - 外碎片拆得很细，使得将来的利用可能性小
            - 易产生很多没用的小碎片
    - 最差适配算法
        - 与最优相反，找差距最大的空闲块
        - 需求
            - 按照大小排序的空闲地址块列表
            - 重新分配需要检查，看是否有空闲块能够合并
        - 优势
            - 分配时中等尺寸时效果最小
        - 劣势
            - 易于破碎大的空间，以致于(将来需要时)大分区无法被分配
            - 重新分配慢


### 连续内存分配：压缩式与交换式碎片整理

- 压缩式碎片整理
    - 重置程序以合并孔洞
    - 要求所有程序是动态可重置的
    - 思考：
        - 何时重置
        - 开销
- 交换式碎片整理(swaping)
    - 运行程序需要更多的内存
    - 把硬盘当作内存的备份(虚拟内存)，将等待需求较长的程序挪到硬盘腾出内存
    - 抢占等待的程序&回收他们的内存
    - 思考
        - 那些程序交换
        - 何时换入换出


## Part 4

### 非连续内存分配：分段

- 连续内存分配的缺点
    - 分配给一个程序的物理内存是连续的
    - 内存利用率低
    - 有外碎片和内碎片的问题
- 为什么需要非连续内存分配(优点)
    - 一个程序的物理地址空间是非连续的
    - 更好的内存利用和管理
    - 允许共享代码和数据
    - 支持动态加载和动态链接
- 非连续分配的缺点
    - 管理开销：如何建立虚拟地址和物理地址之间的转换
        - 软件方案
        - 硬件方案
            - 分段
            - 分页

- 分段
    - 段访问机制
        - 程序访问内存需要一个二维数组(段号s，段内偏移addr)
    - 分段的寻址方案
        - 虚拟内存通过某种映射联系到物理地址
        - 需要一个段表，操作系统建立
        - 需要直到段的大小，防止偏移地址超出范围


### 非连续内存分配：页表

页表其实就是一个大数组，每个运行的程序都有一个页表，每个页表有(page num, offset)
- 属于程序运行状态，会动态变化
- PIBR：页表基址寄存器
- 页表内容
    - Flag标志位
        - dirty bit：是否合法
        - resident bit：物理地址中是否存在
        - clock/reference bit
    - 帧号frame num：f
- CPU通过页号和偏移寻址到对应的页表项，把帧号和偏移组合形成物理地址

- 分页机制的性能问题：
    - 访问一个内存单元需要两次内存地址访问
        - 一次获取表项
        - 一次访问数据
    - 页表可能很大，而且为了隔离每个程序要有自己的页表
    - 页表空间大，因此访问效率页会有问题
- 解决办法
    - 缓存近期访问的页帧转换表项(TLB)
        - TLB使用关联内存实现，具备快速访问性能
        - 如果TLB命中，物理页号可以很快获取
        - 如果TLB未命中TLB miss，对应的表项被更新到TLB中
            - 多数编程(访问)的局部性可以降低TLB miss
    - 间接访问


### 非连续内存分配：页表-二级、多级页表

速度问题解决了，空间上如何解决？那就需要页表分级

以二级页表举例，把一块大的页表分成两块，把大的page num分成两块：p1、p2。
通过一级表[p1]找到二级表的地址，在用二级表地址做索引，二级表[p2]找到frame num就可以找到物理地址。

整个过程多了寻址，导致开销增大，但是通过分级，当物理地址不存在时(在一级表就可以得出)，从而二级表不必保存这部分内容。以时间换空间。
    
多级页表同理


### 非连续内存分配：页表-反向页表

前面所讲的页表的大小都和逻辑地址空间的大小有对应关系，逻辑空间寻址的范围越大，页表越多。

- 大地址空间的问题：
    - 有大地址空间(64bits)，向前映射页表变得繁琐
    - 不是让页表与逻辑空间的大小对应，而是让页表与物理地址空间大小对应

有什么办法使得页表项和逻辑地址空间没有那么大的关系，尽量和物理地址空间大小有关？这就是反向页表的想法。

前面都是以逻辑页号来索引页表(一个大数组)，能否用页帧号(物理页号)来查找对应的逻辑页的页号呢？这样就能省很多空间。

基于哈希查找的方案



## Part 5

### 虚拟内存的起因

理想中的存储器：更大、更快、更便宜的非易失性存储器


### 覆盖技术

- 目标
    - 在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区储存管理配合
- 原理
    - 把程序按照自身逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按照时间先后来运行
        - 必要部分(常用功能)的代码和数据常驻内存
        - 可选部分(不常用功能)在其他程序模块中实现，平时存放在外存中，在需要时才装入内存
        - 不存在调用关系的模块不必同时装入到内存，从而可以 **相互覆盖** 即这些模块共享一个分区


### 交换技术

- 目标
    - 多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源
- 方法
    - 将暂时不能运行的程序送到外存，从而获得空闲内存空间
    - 操作系统把一个进程的整个地址空间的内容保存到外存中(换出swap out)，而将外存中的某个进程的地址空间读入内存中(换入swap in)。换入换出内容的大小为整个程序的地址空间
- 存在的问题
    - 交换的时机：只当内存空间不够或有不够的危险时换出
    - 交换区的大小：必须足够大以存放所有用户进程的所有内存映像的拷贝
    - 程序换入时的重定位：最好采用动态地址映射的方法


### 虚存技术

- 上面方法的不足
    - 覆盖技术：需要程序员自己把整个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加程序员的负担
    - 交换技术：以进程作为交换单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销
- 虚存技术的目标：
    - 像覆盖技术那样，但做的更好，由操作系统完成，不需要程序员的干涉
    - 像交换技术那样，但做的更好，只对进程的部分内容在内存和外存之间进行交换
- 原理：利用程序的局部性
- 基本特征：
    - 大的用户空间：与外存相结合
    - 部分交换：不同于交换技术，可以部分交换
    - 不连续：物理内存分配不连续，虚拟地址空间使用不连续

- 虚拟技术-虚拟页式内存管理
    - 基本思路：
        - 当程序需要调入内存运行时，不是将程序的所有页都装入内存，而是只装如部分页，就可启动程序而运行
        - 在运行的过程中，如果发现运行的程序或要访问的数据不再内存，则发出缺页中断请求，系统在处理这个中断时，将外存中相应的页调入内存，使得程序能够运行

为了事先虚拟页式内存管理，需要在页表项中多加几位：

| 逻辑页号 | 访问位 | 修改位 | 保护位 | 驻留位 | 物理页帧号 |
|----------|--------|--------|--------|--------|------------|

- 驻留位
    - 表示改页是内存还是外存，如果为1,表示在内存中，可以访问，否则导致缺页中断
- 保护位
    - 表示允许对该页做何种类型的访问，如只读、只写等
- 修改位
    - 表示页在内存中是否修改过，当系统回收改物理页时，根据此位来决定是否把它的内存写回到外存(跟新外存的数据)
- 访问位
    - 表明是否访问过。用于置换算法


## Part 6

### 最优页面置换算法

- 功能
    * 当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换
- 目标
    * 尽可能减少页面换入换出的次数

- 最优页面置换算法
    * 思路：当缺页发生时，选择等待时间最长的那个(将来长一段时间不会发生)，作为置换页面
    * 这一种情况实际无法实现的原因是操作系统无法知道每个页面等待多长时间以后消失。所以只能尽可能接近，作为参考来比较其他算法


### 先进先出算法(FIFO)

- 思路
    * 选择在内存中驻留时间最长的页面并淘汰之。即维护一个链表，链表记录所有的逻辑页，链首表示驻留时间最长。缺页时把链首淘汰，把新页添加到链尾
- 性能较差，并且有Belady现象
    * Belady现象
        + 在采用FIFO算法时，有时出现分配的物理页数增加，缺页率反而提高的异常现象


### 最近最久未使用算法(LRU)

- 思路
    * 缺页发生时，替换最久未被使用的页，并淘汰之
    * 利用局部性原理
- 需要记录使用时间的先后顺序，开销较大。两种可能的实现方法：
    * 维护链表
    * 堆栈，最新的压到栈顶，但是要查找一遍把已经存在的剔除


### 时钟页面置换算法

时钟页面置换算法，LRU的近似，对FIFO的一种改进。

- 基本思路
    * 需要用到表项当中的访问位。当一个页面被装入内存时，把该位初始化为0。如果这个页面被访问到，则把该位置置为1
    * 把各个页面组织成环形链表，指针指向最老的页面
    * 当缺页发生时，考虑指针指向的最老的页面，如果它的访问位为0，则淘汰。如果访问位为1，则把它置为0,然后指针往下寻找


### 二次机会法

时钟页面置换算法的访问并没有区分读还是写。实际中如果执行了写操作dirty bit会置为1，如果只是读dirty bit是0。那么dirty bit有什么用呢？

如果进行的是写操作，那么需要同时写到内存和硬盘(数据一致)。如果是只进行读操作，由于内容并没有改变，只需释放内存，然后换入即可。这种使用两个bit的算法就是二次机会法。

used bit、dirty bit的转变规则如下

| 如果          | 则            |
|---------------|---------------|
| used \| dirty | used \| dirty |
| 0     0       | 替换的页      |
| 0     1       | 0     0       |
| 1     0       | 0     0       |
| 1     1       | 0     1       |


### 最不常用算法(LFU)

- 基本思路
    * 缺页发生时，淘汰访问次数最少的页面
- 维护计数器、顺序


### 局部页面替换算法的问题、工作集模型

如果局部性原理不成立，则各种置换算法效果没有区别。如果局部性原理成立，则可以通过工作集模型来表现。

- **工作集** ：一个进程当前正在使用了逻辑页面集合，可以用一个二元函数$W(t, \Delta)$来表示
    * t是当前的执行时刻
    * $\Delta$称为工作集窗口，即一个定长的页面访问的时间窗口
    * $W(t, \Delta)=$在当前时刻t之前的$\Delta$时间窗口当中的所有页面所组成的集合(随着t的变化， 该集合页不断地变化)
    * $|W(t, \Delta)|$值工作集的大小，即页面数目(不同页面的个数)
- **常驻集** ：当前时刻，进程实际驻留在内存的页面集合
    * 工作集是进程在运行过程中固有的性质，而常驻集取决于系统分配进程的物理页的数目，以及所采用的页面置换算法
    * 当常驻集的大小达到某个数目之后，在给他分配更多的物理页面，缺页率页不会明显下降


``` 
    t: 0 1 2 3 4 5 6 7 8 9 10
pages: a c d c b a a b b d b

若Delta=4, t=5, 则
工作集大小=4(dcba)

若Delta=3, t=8, 则
工作集大小=2(abb)
```


### 全局置换算法

把眼光放到整个系统的所有程序，而不仅仅是专注一个程序的页面置换。程序之间物理页需求不同，操作系统可以进行动态调节。

- 缺页率页面置换算法
    * 可变分配策略：常驻集大小可变。如每个进程刚开始的时候，先根据程序大小给它分配一定数目的物理页面，然而在程序运行中，再动态调节常驻集大小
        + 当一个缺页中断发生时，被置换的页面可以是在其他进程当中。各个并发进程竞争地使用物理页面
        + 优缺点：性能较好，但增加了系统开销
        + 具体实现：可以使用缺页率算法来到动态调整常驻集大小


## Part 7

### 进程控制结构

- 进程控制块：操作系统管理控制进程所需的信息集合
    * 操作系统用 **PCB** 来描述进程的基本情况以及运行变化的过程，PCB是进程存在的唯一标志
        + 进程的创建：为该进程生成一个PCB
        + 进程的终止：回收它的PCB
        + 进程的组织管理：通过PCB的组织管理来实现
    * PCB含有以下三大类信息
        + 进程的标识信息
        + 处理机状态信息
        + 进程控制信息
    * PCB的组织方式
        + 链表：经常有动态插入删除的操作系统
        + 索引表(数组)：不常有动态插入删除的操作系统


### 进程的生命周期原理

- 进程创建
    * 引起进程创建的3个主要事件
        + 系统初始化
        + 用户请求创建一个新进程
        + 正在运行的进程执行了创建进程的系统调用
- 进程运行
    * 一个就绪的进程开始运行
- 进程等待
    * 一个进程没有就绪，就进入等待，让其他进程先执行
- 进程唤醒
    * 等待的进程就绪
- 进程结束


### 进程挂起







