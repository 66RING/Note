---
title: 算法学习   
date: 2019-11-26  
tags: 算法, c/c++
mathjax: true
---

# 排序

### 冒泡排序
- 比较大小,如果符合条件(升序)就交换两个元素的位置  
    - 每次执行N-1次
    - 严格大/小,保证了原序(稳定性)
    - 没次能保证最大/最小的元素会在最后
- 如果全程无交换,则说明有序了,跳出即可
- $T=O(x),x\in(N,N^2)$


### 插入排序
- 每次抽取一个元素,然后从序列末尾开始进行比较
- 若符合条件,往后移位,直到不符合条件跳出
- 然后插入元素

#### 希尔排序
对插入排序的改进,每次消除多个逆序对以达到加速的效果  
- 按照一定增量序列,每次进行D排序 $D_N > D_{N-1}...>D_1$ ,这样一来一趟就有可能消除多个逆序对
    - 按照$D_N > D_{N-1}...>D_1$进行排序,后一次会保持前一次的顺序,故可用
    - 但最终都要进行1排序

``` c
for(D=N/2;D>0;D/=2){  // 希尔增量序列。Hibbard增量序列:Dk=2^k-1...等等
    for(p=D;p<N;p++){  // 插入排序
        Tmp = A[p];
        for(i=p;i>=D&&A[i-D]>Tmp;i-=D){
            A[i] = A[i-D];
        }
        A[i] = Tmp;
    }
}
```


### 堆排序
#### 小/大顶堆
子节点比父节点小/大的二叉树  

**构建方法**

``` c
// 法一：上浮下沉法(小顶堆为例)
// 从第一个非叶子节点开始，以它为子树，先自下而上把小的节点上浮，到达子树根节点后自上而下把大的节点下沉
// 知道根节点结束
void createHeap(int *heap,int len){
    for(int j=len/2-1;j>=0;j--){
        int t = j;
        while((t+1)*2<=len){
            int min = (t+1)*2-1;
            if(min+1<len){
                if(heap[min+1]<heap[min]){
                    min++; 
                }
            }
            if(heap[min]<heap[t]){
                swop(min,t,heap);
                t = min;
            }else{
                break;
            }
        }
    }
}


// 法二：插入法
// 从根节点出发，若父节点比插入元素大，则调整位置，如此循环，保证父节点小于子节点
void createHeap(int *heap,int len){
    heap[0] = -1000;
    int temp;
    for(int i=1;i<=len;i++){
        scanf("%d",&temp);
        int j;
        for(j=i;heap[j/2]>temp;j/=2){
            heap[j] = heap[j/2];
        }
        heap[j] = temp;
    }
}
```

#### 利用小/大顶堆排序
- 根据小/大顶堆的性质，可以确定顶部一定是最大或最小的元素
- 交换根节点和最后一个节点，那么最后一个节点一定是最大/最小
- 把最后的节点排除，剩下节点构成的子树再调整成小/大顶堆，重复以上步骤



### 快速排序算法  
通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列    
- 先从数列中取出一个数作为主元
    - 主元选不好会影响速度
    - 法1.选头,中,尾三个数的中位数做主元
- 分区过程，交替移动，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边
- 再对左右区间重复第二步，直到各区间只有一个数

### 擂台法
- 适用于找最值

### 归并法
- 把两个有序的序列合并
- 法1.递归的进行下去(有点类似快速排序)
- 法2.每个元素看成一段序列,合并合并...
- $T=N\log{N}$
- 缺点:需要开额外一份空间



## 拓扑排序
### AOV(activity on vertex)
节点代表事件  
若v到w连通,则v一定在w的前面  
- 有向图
- 有优先级限制
按照此法输出就是拓扑排序  


``` c
Queuezero Q;   // 储存入度为零的,即前头没有限制了的

for(i=0;i<|V|;i++){    // 记录最先的入度为0的节点
    if(indegree[V]==0){
        Enqueue(V,Q);
    }
}
while(!isEmpty(Q)){
    V = Dequeue(Q);  //cnt++,记录或者输出什么的(拓扑排序)
    for(V的每个邻接点W){
        indegree(W)--;
        if(degree(w)==0){
            Enqueue(W,Q);
        }
    }
}
if(cnt!=|V|)
    图有回路,无法拓扑排序
```

### AOE(activity on edge)
例:关键路径问题  


### 表排序
当移动的成本很高时(如移动一部电影)就用表来储存他的顺序
- table[N]指向N,故用table[N]进行访问\排序


### 桶排序
基本原理:假如有10个数分别是0~9让你排序,那建立10个桶ar[10],根据情况0~9放到对应的桶了,最后顺序输出桶就是有序的了

#### LSD(Least Significant Digit)次位优先
排10个在0~999的整数难道要建1000个桶吗？
- 根据低位到高位建通(实际情况肯更抽象)
    - 这里是从个位到百位,没位置建10桶
    - 个位桶建装好后再遍历桶,装十位的桶,以此类推
    - 因为是遍历有序桶来填入新桶的,所以最后的桶只需按顺序输出就是有序了



---


# 查找
### 散列(hash)查找
把关键词看成变量,通过哈希函数运算赋予地址

#### 插入
关键词是数字时的常见方法
- 折叠法
- 平方取中法
- 数字分析法
- 除留余数法

关键词是字符时的常见方法
- 位移法(变成整数移位<<求余)

**核心思想就是当一位改变时尽可能多的影响位数,避免浪费**


#### 处理冲突
产生冲突就添加偏移量到别的位置  
- 线性探测
    - 偏移量是一增量序列: 1.2.3.4...
    - 容易产生聚集
- 平方探测
    - 偏移量是一增量序列: 1^2.2^2.3^2.4^2...
    - 容易产生死循环
        - 定理:散列表长是某个4k+3的素数时,一定能探测整个表
- 双散列探测
    - $d\_i = i\times h\_2(kay)$
    - $h\_2(key)=p-(key mod p)$ 效果最好
- 再散列
    - 装填因子太大是查找效率下降
    - 那就扩大散列表,在把原来的元素搬进去
- 分离链接法
    - 有冲突的关键字都放在(同一个关键字的)一个链表中

**删除时不能直接删除,会影响后续的查找。正确的删除是标记为删除,新的元素来时再替换**



### KMP算法
**要点：** 
- 前缀表next(或者说match)函数的创建

利用前缀表的原理：对于一个子串(如：ababc)，所有可能的前缀:

``` 
a
a b
a b a
a b a b
a b a b c
```

我们需要找出每种可能中最长的、非本身的公共前后缀，因为如果前后缀相同的话，当后缀失去匹配时，可从前缀结束的地方开始匹配，而不是从头开始。

``` 
a               null    0
a b             null    0
a b a           a       1
a b a b         ab      2
a b a b c       null    0  <一般剔除字符串本身,在开头填-1

这些最长公共前后缀的长度就构成了前缀表
 a b a b c
-1 0 0 1 2
这样就表示了当，str[j]失去匹配时，从match[j](前缀结束的地方)尝试匹配
```

**前缀表如何创建**
- 可将创建一个子串前缀表的问题划分为一系列子问题：
    - 创建每种前缀的前缀表
    - 为每种前缀构造前缀表又是一个个子串匹配问题：前1为是否匹配(是否有公共后缀)、前2位是否匹配，...，前n位是否
    - 又因为从最短开始尝试，最短的又为次短的做了铺垫。最短串的KMP创建了次短所需的前缀表

对于ababc，可以划分为：

``` 
a
长的1,不需要前缀表辅助匹配。得到前缀表：
[-1]

a b
对于ab，找最长公共前后缀。找前1位(a)时，相当与在串ab中找匹配的子串a，而子串a的前缀表已经由上一步得出，前2位ab是它本身，结束匹配。得
[-1, 0]

a b a
对于aba，找最长公共前后缀。找前1位(a)时，相当与在串aba中找匹配的子串a，而子串a的前缀表已经由上一步得出，前2位同理。得
[-1 0 1]

a b a b
a b a b c


for(j=1;j<len;j++){
    p = m[j-1];
    //尝试利用前缀表找到匹配的公共前后缀
    while(p>=0&&pattern[p+1]!=pattern[j]){
        p = m[p];
    }

    //如果下一位匹配，公共前后缀长的等于当前匹配的公共前后缀长度加1
    //否则不匹配
    if(pattern[p+1]==pattern[j]){
        m[j] = p+1;
    }else {
        m[j] = -1;
    }
}

```





---


# 树

### 二叉搜索树
- 左边孩子比根节点小
- 右边孩子比根节点大

**查找**  
- 左小右大，递归或循环  

**插入**
- 左小右大，递归或循环  

**删除**
- 没有孩子
    - 直接插入
- 只有一个孩子
    - 子承父业
- 有两个孩子
    - 找到左子树的最大或右子树的最小替换被删除节点...有效降低树的高度

``` c 
BinTree Delete( BinTree BST, ElementType X ) 
{ 
    Position Tmp; 
 
    if( !BST ) 
        printf("要删除的元素未找到"); 
    else {
        if( X < BST->Data ) 
            BST->Left = Delete( BST->Left, X );   /* 从左子树递归删除 */
        else if( X > BST->Data ) 
            BST->Right = Delete( BST->Right, X ); /* 从右子树递归删除 */
        else { /* BST就是要删除的结点 */
            /* 如果被删除结点有左右两个子结点 */ 
            if( BST->Left && BST->Right ) {
                /* 从右子树中找最小的元素填充删除结点 */
                Tmp = FindMin( BST->Right );
                BST->Data = Tmp->Data;
                /* 从右子树中删除最小元素 */
                BST->Right = Delete( BST->Right, BST->Data );
            }
            else { /* 被删除结点有一个或无子结点 */
                Tmp = BST; 
                if( !BST->Left )       /* 只有右孩子或无子结点 */
                    BST = BST->Right; 
                else                   /* 只有左孩子 */
                    BST = BST->Left;
                free( Tmp );
            }
        }
    }
    return BST;
}

```


### 平衡二叉树



### 哈夫曼树


---

# 图

## DFS深度优先搜索
- 从一节点出发
    - 非连通图分而治之
- 依次从访问邻接点,直至所有邻接点都被访问
    - 例:迷宫  

## BFS广度优先搜索
- 从一节点出发
- 把他所有的邻接点入队列,并检测目标节点
- 依次把节点出队列,并递归的把他的邻接点入队列,直到访问所有点
    - 例:树的层序遍历  


### 并查集
若存在两点在同一个连通集合中，则这两点存在回路
- Find() 找根节点
- Union() 合并成集合



## 最短路问题

### Dijkstra算法
解决单源路非递减顺序(没有负)最短路径问题
- 对所有未检索的点进行标记:collected[v] = false
- 从一点出发,记录所有邻接点,若邻接点加入后路径最短,则更新
    - 类似BFS
- 所有邻接点访问完后colleceted[v]=true,从下一个未检索的点继续循环,直到检索所有节点


### Floyd算法
解决多源路非递减顺序最短路径问题   

稠密图有优势  

$T=O(V^3)$  

``` c
// 核心
// 顶点i到顶点j,顶点间的最短路就在矩阵显示出来了
for(k = 0;k<N;k++){
    for(i=0;i<N;i++){
        for(j=0;j<N;j++){
            if(D[i][k]+D[k][j]<D[i][j]){
                D[i][j] = D[i][k]+D[k][j];
                path[i][j] = k;
            }
        }
    }
}
```


### Prim算法
解决稠密图的最小生成树问题  
- 从任意点出发
- 寻找与这个整体相邻,且不构成回路的权最小点
- 加入该整体,继续搜索,直至所有点都收录(生成树必须包含所有点)


### Kruskal算法
解决稀疏图的最小生成树问题  

$T=E\log{E}$  
- 核心思想,每个顶点都是一棵树,把森林连成树
- 找最短且不构成回路的边,又因为每个顶点都是一棵树,每个边都把森林连成树

``` c
MST={};  // 最小生成树
E;   // 边集
while(没够V-1条边&&E没空){
    findmin();  // 找最小边  用最小堆
    delet(E(v,w));  // 把该边移除边集E
    if(E(v,w)加入MST不构成回路)   // 并查集
        join(E(v,w));  // 加入并查集
    else
        单纯的删除
}
if(MST中边不够V-1条)
    生成树不存在
```


---




# 效率问题
### 联机算法
在任意时刻，算法对要操作的数据只读入（扫描）一次，一旦被读入并处理，它就不需要在被记忆了。而在此处理过程中算法能对它已经读入的数据立即给出相应子序列问题的正确答案。具有这种特性的算法叫做联机算法（on-line algorithm。


### 分治算法
在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……
- 该问题的规模缩小到一定的程度就可以容易地解决
- 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质
- 利用该问题分解出的子问题的解可以合并为该问题的解
- 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题


---




