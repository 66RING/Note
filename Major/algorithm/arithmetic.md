---
title: 算法学习   
date: 2019-11-26  
tags: 算法, c/c++
mathjax: true
---

# 排序

### 冒泡排序
- 比较大小,如果符合条件(升序)就交换两个元素的位置  
    - 每次执行N-1次
    - 严格大/小,保证了原序(稳定性)
    - 没次能保证最大/最小的元素会在最后
- 如果全程无交换,则说明有序了,跳出即可
- $T=O(x),x\in(N,N^2)$


### 插入排序
- 每次抽取一个元素,然后从序列末尾开始进行比较
- 若符合条件,往后移位,直到不符合条件跳出
- 然后插入元素

#### 希尔排序
对插入排序的改进,每次消除多个逆序对以达到加速的效果  
- 按照一定增量序列,每次进行D排序 $D_N > D_{N-1}...>D_1$ ,这样一来一趟就有可能消除多个逆序对
    - 按照$D_N > D_{N-1}...>D_1$进行排序,后一次会保持前一次的顺序,故可用
    - 但最终都要进行1排序

``` c
for(D=N/2;D>0;D/=2){  // 希尔增量序列。Hibbard增量序列:Dk=2^k-1...等等
    for(p=D;p<N;p++){  // 插入排序
        Tmp = A[p];
        for(i=p;i>=D&&A[i-D]>Tmp;i-=D){
            A[i] = A[i-D];
        }
        A[i] = Tmp;
    }
}
```


### 堆排序
#### 小/大顶堆
子节点比父节点小/大的二叉树  

**构建方法**

``` c
// 法一：上浮下沉法(小顶堆为例)
// 从第一个非叶子节点开始，以它为子树，先自下而上把小的节点上浮，到达子树根节点后自上而下把大的节点下沉
// 知道根节点结束
void createHeap(int *heap,int len){
    for(int j=len/2-1;j>=0;j--){
        int t = j;
        while((t+1)*2<=len){
            int min = (t+1)*2-1;
            if(min+1<len){
                if(heap[min+1]<heap[min]){
                    min++; 
                }
            }
            if(heap[min]<heap[t]){
                swop(min,t,heap);
                t = min;
            }else{
                break;
            }
        }
    }
}


// 法二：插入法
// 从根节点出发，若父节点比插入元素大，则调整位置，如此循环，保证父节点小于子节点
void createHeap(int *heap,int len){
    heap[0] = -1000;
    int temp;
    for(int i=1;i<=len;i++){
        scanf("%d",&temp);
        int j;
        for(j=i;heap[j/2]>temp;j/=2){
            heap[j] = heap[j/2];
        }
        heap[j] = temp;
    }
}
```

#### 利用小/大顶堆排序
- 根据小/大顶堆的性质，可以确定顶部一定是最大或最小的元素
- 交换根节点和最后一个节点，那么最后一个节点一定是最大/最小
- 把最后的节点排除，剩下节点构成的子树再调整成小/大顶堆，重复以上步骤



### 快速排序算法  
通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列    
- 先从数列中取出一个数作为主元
    - 主元选不好会影响速度
    - 法1.选头,中,尾三个数的中位数做主元
- 分区过程，交替移动，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边
- 再对左右区间重复第二步，直到各区间只有一个数

### 擂台法
- 适用于找最值

### 归并法
- 把两个有序的序列合并
- 法1.递归的进行下去(有点类似快速排序)
- 法2.每个元素看成一段序列,合并合并...
- $T=N\log{N}$
- 缺点:需要开额外一份空间



## 拓扑排序
### AOV(activity on vertex)
节点代表事件  
若v到w连通,则v一定在w的前面  
- 有向图
- 有优先级限制
按照此法输出就是拓扑排序  


``` c
Queuezero Q;   // 储存入度为零的,即前头没有限制了的

for(i=0;i<|V|;i++){    // 记录最先的入度为0的节点
    if(indegree[V]==0){
        Enqueue(V,Q);
    }
}
while(!isEmpty(Q)){
    V = Dequeue(Q);  //cnt++,记录或者输出什么的(拓扑排序)
    for(V的每个邻接点W){
        indegree(W)--;
        if(degree(w)==0){
            Enqueue(W,Q);
        }
    }
}
if(cnt!=|V|)
    图有回路,无法拓扑排序
```

### AOE(activity on edge)
例:关键路径问题  


### 表排序
当移动的成本很高时(如移动一部电影)就用表来储存他的顺序
- table[N]指向N,故用table[N]进行访问\排序


### 桶排序
基本原理:假如有10个数分别是0~9让你排序,那建立10个桶ar[10],根据情况0~9放到对应的桶了,最后顺序输出桶就是有序的了

#### LSD(Least Significant Digit)次位优先
排10个在0~999的整数难道要建1000个桶吗？
- 根据低位到高位建通(实际情况肯更抽象)
    - 这里是从个位到百位,没位置建10桶
    - 个位桶建装好后再遍历桶,装十位的桶,以此类推
    - 因为是遍历有序桶来填入新桶的,所以最后的桶只需按顺序输出就是有序了


## BFPRT算法：求无序数组低k小/大的数

思路类似于partition快速排序，下标就能说明范围是第几，小于放左边大于放右边，然后范围只需要关注左边或者右边。

但是如果是简单的基于快速排序，随机选一个划分值，复杂度的变数就比较大，即如果每次选中的划分值都是最小或最大，那么剩下还得关注len-1的数。效率不高。

- `bfprt(vector<int> arr, int kf)`
    * 1. 整个数组先分组
        + BFPRT发明者是5个人，所以一般5个一组，不足5个就是单独一组
    * 2. 每个小组中排序
    * 3. 取出每个组的中位数，构成一个新的组，偶数个就取上中数或下中数，得到一个N/5长度的新数组
    * 4. 递归调用`num = bfprt(arr, k)`拿到中位数，把上面得到的数组和`new_arr.size()/2`传入
    * 5. 用上一步拿到的中位数进行划分



---


# 查找

### 散列(hash)查找
把关键词看成变量,通过哈希函数运算赋予地址

#### 插入
关键词是数字时的常见方法
- 折叠法
- 平方取中法
- 数字分析法
- 除留余数法

关键词是字符时的常见方法
- 位移法(变成整数移位<<求余)

**核心思想就是当一位改变时尽可能多的影响位数,避免浪费**


#### 处理冲突
产生冲突就添加偏移量到别的位置  
- 线性探测
    - 偏移量是一增量序列: 1.2.3.4...
    - 容易产生聚集
- 平方探测
    - 偏移量是一增量序列: 1^2.2^2.3^2.4^2...
    - 容易产生死循环
        - 定理:散列表长是某个4k+3的素数时,一定能探测整个表
- 双散列探测
    - $d\_i = i\times h\_2(kay)$
    - $h\_2(key)=p-(key mod p)$ 效果最好
- 再散列
    - 装填因子太大是查找效率下降
    - 那就扩大散列表,在把原来的元素搬进去
- 分离链接法
    - 有冲突的关键字都放在(同一个关键字的)一个链表中

**删除时不能直接删除,会影响后续的查找。正确的删除是标记为删除,新的元素来时再替换**



### KMP算法

**要点：** 
- 前缀表next(或者说match)函数的创建
- 动态规划

利用前缀表的原理：对于一个子串(如：ababc)，所有可能的前缀:

``` 
a
a b
a b a
a b a b
a b a b c
```

我们需要找出每种可能中最长的、非本身的公共前后缀，因为如果前后缀相同的话，当后缀失去匹配时，可从前缀结束的地方开始匹配，而不是从头开始。

``` 
a               null    0
a b             null    0
a b a           a       1
a b a b         ab      2
a b a b c       null    0  <一般剔除字符串本身,在开头填-1

这些最长公共前后缀的长度就构成了前缀表
 a b a b c
-1 0 0 1 2
这样就表示了当，str[j]失去匹配时，从match[j](前缀结束的地方)尝试匹配
```

**前缀表如何创建**
- 可将创建一个子串前缀表的问题划分为一系列子问题：
    - 创建每种前缀的前缀表
    - 为每种前缀构造前缀表又是一个个子串匹配问题：前1为是否匹配(是否有公共后缀)、前2位是否匹配，...，前n位是否
    - 又因为从最短开始尝试，最短的又为次短的做了铺垫。最短串的KMP创建了次短所需的前缀表

对于ababc，可以划分为：

``` c
a
长的1,不需要前缀表辅助匹配。得到前缀表：
[-1]

a b
对于ab，找最长公共前后缀。找前1位(a)时，相当与在串ab中找匹配的子串a，而子串a的前缀表已经由上一步得出，前2位ab是它本身，结束匹配。得
[-1, 0]

a b a
对于aba，找最长公共前后缀。找前1位(a)时，相当与在串aba中找匹配的子串a，而子串a的前缀表已经由上一步得出，前2位同理。得
[-1 0 1]

a b a b
a b a b c

for(j=1;j<len;j++){
    p = m[j-1];
    //尝试利用前缀表找到匹配的公共前后缀
    while(p>=0&&pattern[p+1]!=pattern[j]){
        p = m[p];
    }
    //如果下一位匹配，公共前后缀长的等于当前匹配的公共前后缀长度加1
    //否则不匹配
    if(pattern[p+1]==pattern[j]){
        m[j] = p+1;
    }else {
        m[j] = -1;
    }
}
```


#### 实战1：一颗树A是否是另一个树的子树B

序列化A和B树，然后就变成了用KMP找子串的问题了。

关于序列化和反序列化，如何序列化就如何反序列化。如使用先序遍历序列化，得到`1 2 3 # #`，那么也使用先序遍历反序列化得到

``` c
    1
   2 
  3
 # #
```

需要注意的是，一个节点的value表示完毕时，要给出特殊的字符序列化，否则序列化的结果可能会有歧义。

``` c
    12     1
  3      23
如果value表示完不给出特殊字符，那都是
123###

改进：
12!3!#!#!#!
1!23!#!#!#!
```


### Manacher算法：最长回文子串

在中心扩展的基础上， **为了解决字符串长度奇偶的问题，在字符间插入`#`**，这样一来保证找到的所有回文串都是奇数长度。

用`f(i)`来表示第i位为中心，可以拓展出的最大回文半径，那么`f(i)-1`就是以i为中心的最大回文串长度(有一半是`#`)。

Manacher依旧是穷举每一个位置，但是它会动态规划`f(i)`。遍历每个位置算出最右回文右边界，如`01232101`，最右回文右边界就是0处。当最右回文右边界发生变化时，记录回文中心，然后比较是否是新最大回文子串。

- 三种情况的处理方法
    * 1. 当回文中心不在最右回文右边界中时，就暴力扩。
    * 2. 当回文子串，中心在最大回文右边界内，且对称点的回文左右半径在最右回文边界对应的回文左右半径内
        + 那就可以通过对称点直接得出改点的回文半径
        ``` 
        [ ( o ) a ( o ) ]
        L   i   c   i   R
        ```
    * 3. 当回文子串，中心在最大回文右边界内，且对称点的回文左右半径不在最右回文边界对应的回文左右半径内
        + 那到R回文，因为y!=Y，不然最大回文半径还会扩大
        ``` 
        ( y[ o   ) a     o ]Y
           L i     c     i R 
        ```
    * 4. 如果3的情况刚好压线，那就在半径到R的基础上在扩试试


#### Manacher模板

``` c
// 用#预处理好字符串m

// 用rs储存回文半径
// mr为最大回文半径的位置
// c为最大回文半径对应的回文中心
for(int i=1;i<len;i++){

    // 如果在最大回文半径内则取较小值，后面再调整
    // 当前点能到的最大回文半径：rm-i+1
    // 通过对称点得到的回文半径：rs[2*c - i]
    rs[i] = (i<=mr)? min(mr-i+1 , rs[2*c - i]):1;

    // 中心扩展试着找更大半径
    while(m[rs[i]+i] == m[i-rs[i]]) rs[i]++;

    // 更新最大边界及对应回文中心
    if(rs[i]+i-1 > mr){
        mr = rs[i] + i-1;
        c = i;
    }
}
```


### 窗口内最大值

窗口就是用L、R标记窗口的左右边界，而且都只能往右，不能回退。

- 使用一个队列储存下标和值
- 队列只能从大到小排列
    * 当窗口右边界向右，在队列后面，如果队列后面的数小于等于待插入的数，则弹出，直到大于等于
    * 当窗口左边界向右，检查队列前面的值的index是否过期，过期则弹出
- 这么一来，队列顶部的数就是当前窗口中的最大值

``` 
struct Node {
    val
    index
}
```


#### 例题1

找出最大值减最小值*小于*num的所有子数组，且要求时间复杂度为O(n)

- 解：
    * 1. 性质
        + 如果一个数组达标，那它里面的任何一个子数组一定达标
        + 如果一个子数组不达标，那它怎么往外扩都不达标
    * 2. 利用上面的性质，创建一个最小队列和一个最大队列，让L=0，R外扩，直到下一个r不达标
        + 那么**以L开头**的所有子数组都达标，R-L+1个
        + ans += R-L+1
    * 3. 然后L右缩小移位，如果R的下一个可以达标，那就外扩，然后回到第2步
    * 这么就得到了所求


### 单调栈

单调栈：从底到顶是有顺序的，如大到小。

对数组中的每个元素找出它左边最近的大于它的值和右边最近大于它的值。要求时间复杂度O(n)。如：

``` 
3 5 2 4 6
    左      右
3   null    5
5   null    6
2   5       4
...
```

- 1. 建立一个单调栈
- 2. 如果满足单调的顺序要求，则可栈
- 3. 当要入栈的数不满足顺序要求，则开始弹出，并记录数据
    * 如下一个index的4，不满足顺序，那么index为3的数右边最近的比他大的数就是index4对应的数，那么左边最近的比他大的就是弹出后的栈顶
- 4. 弹出后插入是否有序，不满足则再次进行3的操作
- 5. 如果数组遍历完了栈还没空，则依次弹出，无右边最近的大于的数
- 如果两个相同的数相邻，则在栈中他们共用一个位置


#### 例题1

给定一个没有重复元素的数组要求建立一棵树，其中的每一棵子树上，值最大的节点都是树的头部。如果数组长度为n，则时间复杂度要求为O(n)

- 解1. 使用大大根堆
- 解2. 使用单调栈
    * 使用单调栈找出左右最近的大于的信息
    * 若左右都找不到大于的节点，则说明该点最大，做根节点
    * 当左右都有大于的节点时让当前节点成为较小的一个子节点


#### 例题2

给定一个整形矩阵map，其中的值只有0和1两种，求其中全是1的所有矩形区域中，最大的矩形区域中1的数量

``` 
1 0 1 1
1 1 1 1
1 1 1 0
0 1 0 1
```

- 引子题：求组装它所包含的最大的矩形面积
    * 如柱状图的高度分别为：`5 2 3 1 4`最大面积就是6(2往左往右)
    * 这个题的解法就是建立从小到大的单调栈，找出每个元素最右最近的小于的值
    * 然后更新面积信息
- 解
    * 1. 从第一行开始，执行上面的操作找出最大的矩形，更新max值
    * 2. 加上下一行，当以列的元素遇到零时归零
        + 这里加到最后会得到`0 3 0 1`
        + 然后就成为了引子题的问题
    * 这么一个过程下来就记录的最大值


#### 例题3

给一个数组表示一个环形的山，数组的值表示山的高度。每座山顶放烽火，相邻的山可以相互看见，高的山会挡住低的山的视线。求能互相看见的对数。

思路类似例2，中的柱状图，小的山峰找大的山峰，使用最大值打底作出单调栈，找出两边最近的大于的数，弹出时结算对数，一般情况下是2对。需要注意的是：

如果入栈的数和栈顶的数一样大，那就压在一起计数加一，如`4, 4`4个4，当来了的大的值如5
- 结算4个4，则得到的对数为$C_4^2 + 4*2$，C42表示这4个4之间的对数，4x2表示每个4左右都能看到

如果遍历完了栈还非空
- 栈剩余2条以上的记录时，还是公式$C_k^2 + k*2$
- 栈剩2条记录时
    * 如果最后一条记录的个数是大于1，则还是公式
    * 如果最后一条记录的个数是1，则公式把`k*2改为k*1`
- 只剩一条记录是时$C^2_k$


### 字符串匹配

- 递归
    * `f(int i, int j)`，表示str[i]之后的整个能不能被exp[j]之后的整个匹配
        + j+1是\*
            + 如果i，j匹配
            + 如果i，j不匹配
        + j+1不是\*
            + 如果i，j匹配
            + 如果i，j不匹配

暴力递归

``` c
bool process(string& str, string& exp, int i, int j){
    if(j == exp.size()){
        return i == str.size();
    }
    // j上面还有字符，考察j+1的情况
    if(j + 1 == exp.size() || exp[j+1] != '*'){
        return i != str.size() && (exp[j] == str[i] || exp[j] == '.')
            && process(str, exp, i+1, j+1);
    }
    // exp的j+1位置不仅有字符，而且字符是*
    while(i != str.size() && (exp[j] == str[i] || exp[j] == '.')){
        if(process(str, exp, i, j+2)){
            return true;
        }
        i++;
    }
    return process(str, exp, i, j+2);
}
```

动态规划

building...


---


# 树

### Morris遍历


一般方法的遍历树，空间复杂读是O(h)，h是树的高度，因为需要用栈来储存父节点来实现回退。

Morris遍历是在空间复杂度为O(1)的情况下遍历树的方法。它利用了树上的空闲空间

- 1. 当前节点记位Cur，如果Cur无左孩子，Cur向右移动`Cur = Cur.right`
- 2. 如果Cur有左孩子，找到Cur左子树上最右的节点，记做`mostright`
    * 1. 如果`mostright`的右指针是空，让其指向Cur，然后cur向左移动
    * 2. 如果`mostright`的右指针指向cur，让cur右移，然后让其指向空
- 3. 没有右孩子遍历结束

``` c
void func(Node* head){
    if(head==nullptr){
        return
    }
    Node cur = head;
    Node mostRight = null;
    while(cur!=null){
        mostRight = cur.left;
        if(mostRight != nullptr){
            while(mostRight.right != nullptr && mostRight.right != cur){
                mostRight = mostRight.right;
            }
            if(mostRight.right == nullptr){
                mostRight.right = cur;
                cur = cur.left;
                continue;
            }else{  // 第二次来此节点
                mostRight.right = nullptr
                // cur = cur.right; //跳过or not
            }
        }
        cur = cur.right;
    }
}
```


### 二叉搜索树

- 左边孩子比根节点小
- 右边孩子比根节点大

**查找**  
- 左小右大，递归或循环  

**插入**
- 左小右大，递归或循环  

**删除**
- 没有孩子
    - 直接插入
- 只有一个孩子
    - 子承父业
- 有两个孩子
    - 找到左子树的最大或右子树的最小替换被删除节点...有效降低树的高度


``` c 
BinTree Delete( BinTree BST, ElementType X ) 
{ 
    Position Tmp; 
 
    if( !BST ) 
        printf("要删除的元素未找到"); 
    else {
        if( X < BST->Data ) 
            BST->Left = Delete( BST->Left, X );   /* 从左子树递归删除 */
        else if( X > BST->Data ) 
            BST->Right = Delete( BST->Right, X ); /* 从右子树递归删除 */
        else { /* BST就是要删除的结点 */
            /* 如果被删除结点有左右两个子结点 */ 
            if( BST->Left && BST->Right ) {
                /* 从右子树中找最小的元素填充删除结点 */
                Tmp = FindMin( BST->Right );
                BST->Data = Tmp->Data;
                /* 从右子树中删除最小元素 */
                BST->Right = Delete( BST->Right, BST->Data );
            }
            else { /* 被删除结点有一个或无子结点 */
                Tmp = BST; 
                if( !BST->Left )       /* 只有右孩子或无子结点 */
                    BST = BST->Right; 
                else                   /* 只有左孩子 */
                    BST = BST->Left;
                free( Tmp );
            }
        }
    }
    return BST;
}
```


### 平衡二叉树

节点左边都比该节点小，右边都比该节点大

不考虑平衡性的情况下

- 插入
    * 左小右大，找到自己的位置
- 删除
    * 当左右子树都非空时，用右子树的最左节点顶替，该节点的右子树交给它的父节点
        + 因为右子树最左节点是最小的比它大的数
        + 同理，也可选左子树的最右节点

- 如果考虑平衡性不同的平衡二差数动作的组合不同，但基本思想(动作)都是**通过旋转来改变局部的平衡性**
    - 左旋：头节点变成了新头节点的左节点
        * 如果新头节点存在左孩子，则成为旧头节点的右孩子。因为对于左旋，新头节点本来是旧头节点的右孩子
    - 右旋：头节点变成了新头节点的右节点
        * 如果新头节点存在右孩子，则成为旧头节点的左孩子。因为对于右旋，新头节点本来是旧头节点的左孩子


#### AVL树

- 发现不平衡
    * 把左树高度和右树高度记录在节点中，当插入新节点时回溯，修改沿途的值，修改过程中将发现不平衡。删除节点同理
- 当发现不平衡时进行旋转，**4种调整的组合**
    * LL：左子树的左子树导致的不平衡
        + 单纯的右旋
        + 即`node.left.left != NULL`的情况：因为向上3级就能发现不平衡
    * LR：左子树的右子树导致的不平衡
        + 先左旋再右旋：
            + 先以头节点的左子节点为新头节点左旋
            + 然后就转化成了LL型的操作
        + 即`node.left.right != NULL`的情况
    * RR：右子树的右子树导致的不平衡
        + 单纯的左旋
        + 即`node.right.right != NULL`的情况
    * RL：右子树的左子树导致的不平衡
        + 即`node.right.left != NULL`的情况
        + 同理LR型


#### 红黑树

为表述方便：C(current)表示针对的节点，P(parent), G(grandparent)，U(uncle)

- 特征
    * 1. 根节点是黑色
    * 2. 所有叶子(nil节点)都是黑色
    * 3. 每个红色节点的两个字节点都是黑色(不存在两个连续的红色节点)
    * 4. 从任意节点到其每个叶子的所有路径都包含相同数目的黑色节点
        + 黑色完美平衡
- 旋转：为例减小树的高度
    * 红黑树最大高度$O(\log n)$
    * 左旋：
        + C和它的右子节点交换
        + C右子节点的左子树成为C的右子树
        + 右子变新爹，右子的左子变老爹的右子，老爹变新爹左子
        ``` 
        # LEFT-ROTATE(T, x)
        y = x.right
        x.right = y.left
        if y.left != nil
            y.left.p = x
        y.p = x.p
        if x.p == nil
            T.root == y
        elseif x == x.p.left
            x.p.left = y
        else x.p.right = y
        y.left = x
        x.p = y
        ```
    * 右旋：
        + C和它的左子节点交换
        + C左子节点的右子树成为C的左子树
        + 左子变新爹，左子的右子变老爹的左子，老爹变新爹右子
- 搜索
    * 比节点小就找左子树，否则右子树
- 插入
    * 每个新节点都是红色的，违规修复代价比较小
    * 1. C=root，则把C变为黑色
    * 2. P是黑色，直接插入
    * 3. P是红色
        + I. U是红，则P和U都变黑，G变后，向上递归
        + II. U是黑
            + 三角型：GPC呈三角形
                + 对P旋转使得GPC一条直线，然后做直线型操作
            + 直线型：GPC一条直线
                + 对G旋转，然后交换G和P的颜色
- 删除
    *  **building** 


### 哈夫曼树


---

# 图

## DFS深度优先搜索
- 从一节点出发
    - 非连通图分而治之
- 依次从访问邻接点,直至所有邻接点都被访问
    - 例:迷宫  

## BFS广度优先搜索
- 从一节点出发
- 把他所有的邻接点入队列,并检测目标节点
- 依次把节点出队列,并递归的把他的邻接点入队列,直到访问所有点
    - 例:树的层序遍历  


### 并查集
若存在两点在同一个连通集合中，则这两点存在回路
- Find() 找根节点
- Union() 合并成集合



## 最短路问题

### Dijkstra算法
解决单源路非递减顺序(没有负)最短路径问题
- 对所有未检索的点进行标记:collected[v] = false
- 从一点出发,记录所有邻接点,若邻接点加入后路径最短,则更新
    - 类似BFS
- 所有邻接点访问完后colleceted[v]=true,从下一个未检索的点继续循环,直到检索所有节点


### Floyd算法
解决多源路非递减顺序最短路径问题   

稠密图有优势  

$T=O(V^3)$  

``` c
// 核心
// 顶点i到顶点j,顶点间的最短路就在矩阵显示出来了
for(k = 0;k<N;k++){
    for(i=0;i<N;i++){
        for(j=0;j<N;j++){
            if(D[i][k]+D[k][j]<D[i][j]){
                D[i][j] = D[i][k]+D[k][j];
                path[i][j] = k;
            }
        }
    }
}
```


### Prim算法
解决稠密图的最小生成树问题  
- 从任意点出发
- 寻找与这个整体相邻,且不构成回路的权最小点
- 加入该整体,继续搜索,直至所有点都收录(生成树必须包含所有点)


### Kruskal算法
解决稀疏图的最小生成树问题  

$T=E\log{E}$  
- 核心思想,每个顶点都是一棵树,把森林连成树
- 找最短且不构成回路的边,又因为每个顶点都是一棵树,每个边都把森林连成树

``` c
MST={};  // 最小生成树
E;   // 边集
while(没够V-1条边&&E没空){
    findmin();  // 找最小边  用最小堆
    delet(E(v,w));  // 把该边移除边集E
    if(E(v,w)加入MST不构成回路)   // 并查集
        join(E(v,w));  // 加入并查集
    else
        单纯的删除
}
if(MST中边不够V-1条)
    生成树不存在
```


### A星寻路算法

- 启发性搜索：f = g + h
    * f：当前点到终点的代价
    * g：起点到当前点的代价
    * h：当前点到终点的 **预估代价**
        + 忽略障碍，只算直线距离，但是移动时只走无障碍的路
- 过程
    * 使用一个OPEN列表保存能走且未走过的路
    * 使用一个CLOSED列表保存走过的路
    * 将起点放入OPEN列表
    * 循环
        + 1. **current=OPEN列表中f最小的点**
        + 2. OPEN中移出current放入CLOSED
        + 3. 如果current是终点，则循环结束
        + 3. 遍历current的所有邻居(其中的邻居不能是CLOSED中、不能是障碍物)
        + 4. 计算邻居的f
        + 5. 将邻居的parent设为current
        + 6. 将邻居放入OPEN列表
    * 最后从终点一直沿着父节点走就找到了最短路径


---




# 效率问题
### 联机算法
在任意时刻，算法对要操作的数据只读入（扫描）一次，一旦被读入并处理，它就不需要在被记忆了。而在此处理过程中算法能对它已经读入的数据立即给出相应子序列问题的正确答案。具有这种特性的算法叫做联机算法（on-line algorithm。


### 分治算法
在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……
- 该问题的规模缩小到一定的程度就可以容易地解决
- 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质
- 利用该问题分解出的子问题的解可以合并为该问题的解
- 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题


---


# 回溯

### 全排列

给定一个 没有重复 数字的序列，返回其所有可能的全排列。

``` 
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

- 思路，可以模拟全排列的过程，一个一个插入。只是不同的方法优劣程度不同
    * 妙：通过交换位置维护已选数，回溯时再换回来
        + 1. 优化空间，不需要而外空间保存已选
        + 2. 优化未选数查询，交换后已选的数都排在了前头，未选的数从剩余长度开始就是

``` c
void backtrack(vector<vector<int>>& res, vector<int>& output, int first, int len){
    // 所有数都填完了
    if (first == len) {
        res.emplace_back(output);
        return;
    }
    for (int i = first; i < len; ++i) {  // first表示要插入的位置，i表示要选择插入的对象
        // 使用交换来维护已选数组
        swap(output[i], output[first]);
        // 继续递归填下一个数
        backtrack(res, output, first + 1, len);
        // 撤销操作
        swap(output[i], output[first]);
    }
}
```


# 位运算

## 布隆过滤器

设有100亿个黑名单网页，每个网页URL占用64字节，想要实现一种网页过滤系统，过滤黑名单，允许有万分之一的判断失误，且而外空间不超过30G。

如果用哈希表存入数据库，但是至少需要640G空间。这样对空间要求比较严格，但允许一定失误的过滤系统，往往是  **布隆过滤器：使用很少的空间就能把正确率做到很高的程度** 

布隆过滤器可以精确的代表一个集合，可精确到判断某一元素是否在集合中，但100%的精确是不可能的。

- 加入布隆过滤器
    * 一个长度为m的bit类型的数组`bitarray`，每个位置只有0(白)和1(黑)
    * 有k个哈希函数，这些哈希函数都足够优秀，且输出域都大于等于m
    * 对于一个对象，如64字节的URL通过k个哈希函数
        + 哈希的结果对m取余，取余的结果在bitarray上将相应的位置设为1(涂黑)
    * 使用该方法处理所有的对象，如果遇到已经涂黑的位置，则让其保持黑
- 检查
    * 将对象通过这k个哈希函数，取余等操作，找到bitarray上对应的位置
    * 如果得到的位置都为黑色，则就是黑名单中，否则不是
    * 但是也有可能误判，将白的判为黑的


### bitarray和k大小的确定

bitarray大小m由样本数量n和能容忍的驶入率p决定。上题中$m=100亿，p=0.01%$

$$
m = - \frac{n \times lnp}{(ln2)^2} \\
k = ln2 \times \frac mn = 0.7 \times \frac mn
$$


## 不用额外空间交换量整数的值

``` c
a = a0;
b = b0;
a = a^b;  // a=a0^b0, b=b0
b = a^b;  // a=a0^b0, b=a0^b0^b0=a0
a = a^b;  // a=a0^b0^a0=b0, b=a0
```


## 奇数次偶数次

- 1. 假设一个数组中只有一个数出现了奇数次，其他数都出现了偶数次，要求在时间复杂度0(1)的情况下找出这个数。
    * 使用一个数a=0，与arr中的每一个数[c, b, a, c, b, a, d]异或，结果就是这个数
    * 因为异或运算满足交换率和结合率，异或的次序就可以是[aabbccd]，所以得到d
- 2. 第一题小小改进，有两个数出现奇数次
    * 先与每个数异或最后剩下`a=b^c`
    * 因为b和c是不同的数，所以a不为0，找到为1的一位，假设是第k位
    * 因为低k位为1，说明a和b的第k位一定不一样
    * 第二次遍历让a2=0只与与第k位为1的数异或，则异或的结果就是a和b中的一个
    * `a^a2`的结果就是a和b中的另一个


# 动态规划

从暴力搜索 推导出 动态规划，然后优化


## 动态规划与记忆搜索的关系

给定一个集合，{1, 5, 10, 15, 25}，求组合得到一个数target是所有组合数。

- 递归
    * 遍历数组，取一个值后，用剩下target继续递归执行
    *  **大量重复计算**，对于一个target值，组合数是相同的，不需要每次都从头计算
- 记忆搜索
    * 使用一个map记录某个状态下target对应的组合数，如果没计算过才算，否则直接取值
    *  **区别于动态规划** ，记忆搜索"不规定计算顺序"，遇到无记忆的就算
- 动态规划
    * 生成行数为N，列数位aim+1的矩阵dp(dynamic programming)，`dp[i][j]`表示使用`arr[0...i]`货币的情况下，组成钱数j有多少种方法
    * 动态规划规定每一种递归状态下的计算顺序，依次进行计算
    * 动态规划严格规定计算顺序，存在进一步优化的可能







