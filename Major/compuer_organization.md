---
title: Computer Organization
date: 2019-12-10
tags: cs
mathjax: true
---

## 简介

- 从纯文本的程序到可执行的编码，以`hello.c`为例
    - 预处理：把头文件的内容直接插入程序文本。结果得到另一个c程序，通常以.i结尾
    - 编译：编译器将本文文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序
    - 汇编：汇编器将hello.s翻译成机器指令(编码)，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中(一个二进制文件)。
    - 链接：hello程序可能会用到许多函数，如printf。printf函数存在与一个名为printf.o的单独编译的与编译好了的目标文件中，这个文件需要以某种形式合并到我们的hello.o程序中。链接器就负责处理这种合并


- 虚拟内存：虚拟内存是一个抽象概念，它为每个进程提供一个假象，即每个进程都在单独的使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间
- 虚拟地址空间的结构：
    - 程序代码和数据
    - 堆：代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的函数时，堆可以在运行时动态伸缩
    - 共享库：大约在地址空间的中间部分是一块用来存放像C标准这样的共享库的代码和数据的区域
    - 栈
    - 内核虚拟内存：地址空间的顶部区域是为内核保留的。不允许任何程序的读写


## 程序结构和执行

### 整数运算

#### 无符号加法

考虑两个非负整数x和y，满足$0 \leq x, y<2^w$。每个数都能表示为w为无符号数字。如果计算他们的和，我们就有一个可能的范围$0 \leq x+y \leq 2^{w+1} - 2$，表示这个和可能需要w+1位。对于固定精度的编程语言会发生溢出。

我们为x和y定义运算$+^u_w, 其中0 \leq x, y < 2^w$，该操作是把整数和x+y截断为w位得到的结果。这也可以被视为一种形式的模运算，对于x+y的位级表示，简单的丢弃任何权重大于$2^{w-1}$的位就可以计算出和模$2^w$。如考虑一个4位数字表示$x=12, y=9,x+y=21([10101])$如果丢掉最高位，我们的到[0101]，也就是十进制的5。也就和值21 mod 16 = 6一致。

> 定义$+^u_w$:
> 
> 对于满足$0 \leq x, y < 2^w$的x和y有
> 
> $$
> x+^u_w y = 
> \begin{cases}
> x+y& ,{x+y<2^w}& 正常\\
> x+y-2^w& ,{2^w \leq x+y < 2^{w+1}}& 溢出
> \end{cases}
> $$

如何判断是否发生了溢出：
- 原理：对在范围$0 \leq x, y \leq UMax_w$中的x和y，令$s = x +^u_w y$。则对计算是，当且仅当s\<x(或等价地s\<y)时发生溢出
- 推导：显然$x+y \geq x$，因此如果s没有溢出$s \geq x$。如果s发生溢出，有$s = x+y-2^w$，假设$y < 2^w$，有$y-2^w < 0$，因此$s = x+(y-2^w) < x$


#### 乘以常数

整数乘法指令相当慢，需要多个时钟周期，然而其他的整数运算(如加法、减法、位移)之需要1个时钟周期。因此编译器使用了一项重要的优化：试着用移位和加法运算的组合来代替乘以常数因子的乘法。

如$x \times 14$，$14=2^3+2^2+2^1$，编译器将乘法重写为(x<<3)+(x<<2)+(x<<1)，将一个乘法代替为3个移位和2个加法。甚至还可以$14=2^4-2^1$。

到这里，无符号数和补码的结果还是相同的


#### 除以2的幂

在大多数机器上，整数除法要比整数乘法更慢：需要30个或者更多的时钟周期。除以2的幂也可以通过用移位(左移)运算来实现。

无符号和补码数分别使用逻辑移位和算数移位来达到目的：
- 逻辑移位
    - 移出的空位用0补上
- 算术移位
    - 对于无符号型，算术移位等同于逻辑移位
    - 对于有符号型，算数左移等同于逻辑左移，算数右移补的是符号位

> 定义$\lfloor a \rfloor$为向下舍入，$\lceil a \rceil$为向上舍入。

对于$x \geq 0$和$y>0$，结果会是$\lfloor x/y \rfloor$，对于$x<0$和$y>0$，结果会是$\lceil x/y \rceil$。也就是说要向下舍入一个正值，而向上舍入一个负值。

- 除以2的幂的无符号数除法
    - 很简单，就直接右移，产生$\lfloor x/2^k \rfloor$
- 除以2的幂的补码，正值情况，向下舍入
    - 也是直接右移，直接右移的结果是向下舍入的
- 除以2的幂的补码，负值情况，向上舍入
    - 不能直接右移，因为直接右移导致结果向下舍入，而我们需要向上舍入
    - 执行算数右移前要加上一个适当的偏执量才能使得结果正确舍入
    - 表达式：(x+(1\<\<k)-1)\>\>k产生数值$\lceil x/2^k \rceil$
    - 偏置技术利用如下属性：对于整数x和y(y>0)，$\lceil x/y \rceil=\lfloor (x+y-1)/y \rfloor$。这样就可以通过逻辑移位来的到向上取整的结果了
    - **推导:** $\lceil x/y \rceil=\lfloor (x+y-1)/y \rfloor$，设$x = qy+r$，其中$0 \leq r < y$，得到(x+y-1)/y=q+(r+y-1)，因此$\lfloor (x+y-1)/y \rfloor = q + \lfloor (r+y-1)/y \rfloor$。当r=0时，后面一项等于0，当r>0时，等于1。级通过给x增加一个偏移量y-1,然后再将除法向下舍入，当y整除x时，我们得到q，否则，得到q+1。













