---
title: Computer Organization
date: 2019-12-10
tags: cs
mathjax: true
---

## 简介

- 从纯文本的程序到可执行的编码，以`hello.c`为例
    - 预处理：把头文件的内容直接插入程序文本。结果得到另一个c程序，通常以.i结尾
    - 编译：编译器将本文文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序
    - 汇编：汇编器将hello.s翻译成机器指令(编码)，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中(一个二进制文件)。
    - 链接：hello程序可能会用到许多函数，如printf。printf函数存在与一个名为printf.o的单独编译的与编译好了的目标文件中，这个文件需要以某种形式合并到我们的hello.o程序中。链接器就负责处理这种合并


- 虚拟内存：虚拟内存是一个抽象概念，它为每个进程提供一个假象，即每个进程都在单独的使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间
- 虚拟地址空间的结构：
    - 程序代码和数据
    - 堆：代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的函数时，堆可以在运行时动态伸缩
    - 共享库：大约在地址空间的中间部分是一块用来存放像C标准这样的共享库的代码和数据的区域
    - 栈
    - 内核虚拟内存：地址空间的顶部区域是为内核保留的。不允许任何程序的读写


## 程序结构和执行

### 整数运算

#### 无符号加法

考虑两个非负整数x和y，满足$0 \leq x, y<2^w$。每个数都能表示为w为无符号数字。如果计算他们的和，我们就有一个可能的范围$0 \leq x+y \leq 2^{w+1} - 2$，表示这个和可能需要w+1位。对于固定精度的编程语言会发生溢出。

我们为x和y定义运算$+^u_w, 其中0 \leq x, y < 2^w$，该操作是把整数和x+y截断为w位得到的结果。这也可以被视为一种形式的模运算，对于x+y的位级表示，简单的丢弃任何权重大于$2^{w-1}$的位就可以计算出和模$2^w$。如考虑一个4位数字表示$x=12, y=9,x+y=21([10101])$如果丢掉最高位，我们的到[0101]，也就是十进制的5。也就和值21 mod 16 = 6一致。

> 定义$+^u_w$:
> 
> 对于满足$0 \leq x, y < 2^w$的x和y有
> 
> $$
> x+^u_w y = 
> \begin{cases}
> x+y& ,{x+y<2^w}& 正常\\
> x+y-2^w& ,{2^w \leq x+y < 2^{w+1}}& 溢出
> \end{cases}
> $$

如何判断是否发生了溢出：
- 原理：对在范围$0 \leq x, y \leq UMax_w$中的x和y，令$s = x +^u_w y$。则对计算是，当且仅当s\<x(或等价地s\<y)时发生溢出
- 推导：显然$x+y \geq x$，因此如果s没有溢出$s \geq x$。如果s发生溢出，有$s = x+y-2^w$，假设$y < 2^w$，有$y-2^w < 0$，因此$s = x+(y-2^w) < x$


#### 乘以常数

整数乘法指令相当慢，需要多个时钟周期，然而其他的整数运算(如加法、减法、位移)之需要1个时钟周期。因此编译器使用了一项重要的优化：试着用移位和加法运算的组合来代替乘以常数因子的乘法。

如$x \times 14$，$14=2^3+2^2+2^1$，编译器将乘法重写为(x<<3)+(x<<2)+(x<<1)，将一个乘法代替为3个移位和2个加法。甚至还可以$14=2^4-2^1$。

到这里，无符号数和补码的结果还是相同的


#### 除以2的幂

在大多数机器上，整数除法要比整数乘法更慢：需要30个或者更多的时钟周期。除以2的幂也可以通过用移位(左移)运算来实现。

无符号和补码数分别使用逻辑移位和算数移位来达到目的：
- 逻辑移位
    - 移出的空位用0补上
- 算术移位
    - 对于无符号型，算术移位等同于逻辑移位
    - 对于有符号型，算数左移等同于逻辑左移，算数右移补的是符号位

> 定义$\lfloor a \rfloor$为向下舍入，$\lceil a \rceil$为向上舍入。

对于$x \geq 0$和$y>0$，结果会是$\lfloor x/y \rfloor$，对于$x<0$和$y>0$，结果会是$\lceil x/y \rceil$。也就是说要向下舍入一个正值，而向上舍入一个负值。

- 除以2的幂的无符号数除法
    - 很简单，就直接右移，产生$\lfloor x/2^k \rfloor$
- 除以2的幂的补码，正值情况，向下舍入
    - 也是直接右移，直接右移的结果是向下舍入的
- 除以2的幂的补码，负值情况，向上舍入
    - 不能直接右移，因为直接右移导致结果向下舍入，而我们需要向上舍入
    - 执行算数右移前要加上一个适当的偏执量才能使得结果正确舍入
    - 表达式：(x+(1\<\<k)-1)\>\>k产生数值$\lceil x/2^k \rceil$
    - 偏置技术利用如下属性：对于整数x和y(y>0)，$\lceil x/y \rceil=\lfloor (x+y-1)/y \rfloor$。这样就可以通过逻辑移位来的到向上取整的结果了
    - **推导:** $\lceil x/y \rceil=\lfloor (x+y-1)/y \rfloor$，设$x = qy+r$，其中$0 \leq r < y$，得到(x+y-1)/y=q+(r+y-1)，因此$\lfloor (x+y-1)/y \rfloor = q + \lfloor (r+y-1)/y \rfloor$。当r=0时，后面一项等于0，当r>0时，等于1。级通过给x增加一个偏移量y-1,然后再将除法向下舍入，当y整除x时，我们得到q，否则，得到q+1。


### 浮点数

#### IEEE浮点数表示

定点表示法不能很有效地表示非常大的数字。我们希望通过给定x和y的值，来表示形如$x \times 2^y$的数。
 
> IEEE浮点数标准用$V = (-1)^s \times M \times 2^E$的形式来表示一个数：
> - 符号(sign)
>     - s决定是负数(s=1)还是正数
> - 尾数(significand) M
>     - M是一个二进制小数，它的取值范围是[1, 2)或[0, 1)
>     - 有n位小数字段$frac=f_{n-1}...f_0$编码尾数M，但编码出来的值也依赖于阶码字段是否等于0(规格化的和非规格化的)
> - 阶码(exponent) E
>     - E的作用是对浮点数加权，这个权重是2的E次幂
>     - 由k位的阶码字段组成$exp=e_{k-1}...f_0$来编码阶码E


- 以下是两种常见的格式：单精度和双精度
    - 单精度:s、exp、frac字段分别为1位、k=8位和n=23位，得到一个32位的表示
    - 双精度:s、exp、frac字段分别为1位、k=11位和n=52位，得到一个64位的表示
- 给定位的表示，根据exp的值，被编码的值可以分成三种不同的情况(最后一种情况有两种变种)
    - 规格化的
        - exp字段既不全为0也不全为1
        - 阶码的值E=e-Bias，e是无符号数，而$Bias=2^{k-1}-1$的偏置值
        - 尾数M=1+f，f是frac字段描述的小数值$0 \leq f < 1$
    - 非规格化的值
        - exp字段全为0时
        - 阶码E=1-Bias
        - 尾数M=f
        - 注意和规格化的区别
    - 特殊值
        - 当exp全为1，frac字段全为0时，得到的值表示无穷
        - 当exp全为1，frac字段不全为0时，得到的值表示NaN(Not a Number)

示例：假定用6位格式表示，k=3的阶码位和n=2的尾数位，如下

| 描述           | 位表示     | e   | E  | $2^E$        | f         | M            | $2^E \times M$ | V             | 十进制   | 公式     |
|----------------|------------|-----|----|--------------|-----------|--------------|----------------|---------------|----------|----------|
| 0              | 0 0000 000 | 0   | -6 | $\frac1{64}$ | $\frac08$ | $\frac08$    | $\frac0{512}$  | 0             | 0.0      | E=1-Bias |
| 最小非规格化数 | 0 0000 001 | 0   | -6 | $\frac1{64}$ | $\frac18$ | $\frac18$    | $\frac1{512}$  | $\frac1{512}$ | 0.001953 | M=f      |
|                | 0 0000 010 | 0   | -6 | $\frac1{64}$ | $\frac28$ | $\frac38$    | $\frac2{512}$  | $\frac1{256}$ | 0.003906 |          |
| ...            | ...        | ... | .. | ...          |           |              |                |               |          |          |
| 最大非规格化数 | 0 0000 111 | 0   | -6 | $\frac1{64}$ | $\frac78$ | $\frac78$    | $\frac7{512}$  | $\frac7{512}$ | 0.013672 |          |
| --------       | ------     | --  | -- | ---          | ----      | ----         | ------         | -----         | -----    |          |
| 最小规格化数   | 0 0001 000 | 1   | -6 | $\frac1{64}$ | $\frac08$ | $\frac88$    | $\frac8{512}$  | $\frac1{64}$  | 0.015625 | E=e-Bias |
|                | 0 0001 001 | 1   | -6 | $\frac1{64}$ | $\frac18$ | $\frac98$    | $\frac9{512}$  | $\frac9{256}$ | 0.017578 | M=1+f    |
| ...            | ...        | ... | .. | ...          |           |              |                |               |          |          |
|                | 0 1110 110 | 14  | 7  | 128          | $\frac68$ | $\frac{14}8$ | $\frac{1792}8$ | 224           | 224      |          |
| 最大规格化数   | 0 1110 111 | 14  | 7  | 128          | $\frac78$ | $\frac{15}8$ | $\frac{1920}8$ | 240           | 240      |          |
| --------       | ------     | --  | -- | ---          | ----      | ----         | ------         | -----         | -----    |          |
| 无穷大         | 0 1111 000 | -   | -  | -            | -         | -            | -              | 无穷          | -        |          |


## 程序的机器级表示

### 数据格式

| C声明    | Intel数据类型 | 汇编代码后缀 | 大小(字节) |
|----------|---------------|--------------|------------|
| char   | 字节          | b            | 1          |
| short  | 字            | w            | 2          |
| int    | 双字          | l            | 4          |
| long   | 四字          | q            | 8          |
| char\* | 四字          | q            | 8          |
| float  | 单精度        | s            | 4          |
| double | 双精度        | l            | 8          |


### 访问信息

一个x86-64的CPU包含一组16个储存64位值的通用目的寄存器。每个寄存器都有特殊的用途，它们的名字就反映了这些用途。

| 64寄存器 | 32位寄存器 | 16位寄存器 | 8位寄存器 | 用途         |
|----------|------------|------------|-----------|--------------|
| %rax     | %eax       | %ax        | %ax       | 返回值       |
| %rbx     | %ebx       | %bx        | %bl       | 被调用者保存 |
| %rcx     | %ecx       | %cx        | %cl       | 第4个参数    |
| %rdx     | %edx       | %dx        | %dl       | 第3个参数    |
| %rsi     | %esi       | %si        | %sil      | 第2个参数    |
| %rdi     | %edi       | %di        | %dil      | 第1个参数    |
| %rbp     | %ebp       | %bp        | %bpl      | 被调用者保存 |
| %rsp     | %esp       | %sp        | %spl      | 栈指针       |
| %r8      | %r8d       | %r8w       | %r8b      | 第5个参数    |
| %r9      | %r9d       | %r9w       | %r9b      | 第6个参数    |
| %r10     | %r10d      | %r10w      | %r10b     | 调用者保存   |
| %r11     | %r11d      | %r11w      | %r11b     | 调用者保存   |
| %r12     | %r12d      | %r12w      | %r12b     | 被调用者保存 |
| %r13     | %r13d      | %r13w      | %r13b     | 被调用者保存 |
| %r14     | %r14d      | %r14w      | %r14b     | 被调用者保存 |
| %r15     | %r15d      | %r15w      | %r15b     | 被调用者保存 |

指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。


## MIPS体系结构

Microprocessor without Interlocked Piped Stage，流水线不会互锁的处理器。避免不同指令间的相互影响。如x86指令的标志寄存器，前一条指令作出的改动会对后面的产生影响，这MIPS所要避免的。

- 它的主要关注点
    - 减少指令类型
    - 降低指令复杂度
- 基本原则是用非常简单的CPU解决非常复杂的系统
    - 越简单的CPU越快
- MIPS特点
    - 固定指令长度(32bit)
        - 简化了从存储器取指令
    - 简单的寻址模式
        - 简化了从存储器取操作数
    - 指令数量少，功能简单
        - 一条指令之完成一个操作
        - 简化指令的执行过程
    - 只允许Load和Store指令访问存储器
    - MIPS这些特点让使用MIPS进行编程变得困难


### 基本指令

- 格式：`OPT a, b, c`
    - 如`add a, b, c`将b和c求和，结果存如a中
    - 如此还有
        - `sub a, b, c`
        - `mul a, b, c`
        - `div a, b, c`
        - `and a, b, c`
        - `or a, b, c`
        - `sll a, b, c`，左移
        - `srl a, b, c`，右移

指令高度统一，而且操作数都不可是存储器操作数，要使用存储器就必须使用专门的访存指令。

- `lw $a, $b`, load word，读取寄存器b的字(32bit)，放入a中
    - MIPS的寄存器编号用`$`符进行标记
- `sw $a, $b`, store word，将寄存器a的字(32bit)，存到b中

MIPS有32个通用寄存器，编号从0到31，可以实用`$`加编号进行指示，也可使用他们的名称(每个寄存器都另有一个名称，并约定了特定的用途)


### 指令的基本格式

MIPS的指令非常的精简，指令分为3种类型
- R：Register，寄存器
- I：Immediate，立即数
- J：Jump，转移


#### R型
         
| R         | opcode | rs    | rt    | rd    | shamt | funct |
|-----------|--------|-------|-------|-------|-------|-------|
| 大小(bit) | 6      | 5     | 5     | 5     | 5     | 6     |
| 位置      | 31~26  | 25~21 | 20~16 | 15~11 | 10~6  | 5~0   |

- R型指令的格式
    - opcode域指定指令的类型，对于R型指令均为0
    - funct来精确指定指令的类型
    - rs：Source Register，通常指定第一个源操作数所在寄存器编号
    - rt：Target Register，通常指定第二个源操作数所在寄存器编号
    - rd：Destination Register，通常指定目的操作数所在寄存器编号
    - shamt用于指定移位指令进行操作数的位数，对于非移位指令为0

- 通过指令得到编码，如`add $8, $9, $10`
    - 查MIPS的指令编码表：对于add，opcode=0, funct=32, shamt=0
    - 分析指令操作数：rd=8, rs=9, rt=10
    - 把对应的值转化为二进制数即可得到编码


#### I型

如果只用5bit来表示立即数，显然不够用，所以对于I型指令需要新的格式


| I         | opcode | rs    | rt    | immediate |
|-----------|--------|-------|-------|-----------|
| 大小(bit) | 6      | 5     | 5     | 16        |
| 位置      | 31~26  | 25~21 | 20~16 | 15~0      |

- I型指令的格式
    - opcode域指定指令的类型，没有funct
    - funct来精确指定指令的类型
    - rs：Source Register，通常指定第一个源操作数所在寄存器编号
    - rt：Target Register，通常指定第二个源操作数所在寄存器编号
    - immediate可以存放16位的立即数

- 通过指令得到编码，如`add $21, $22, -50`
    - opcode=8
    - rs=22, rt=21, immedaite=-50


#### 分支指令(条件指令)

- 条件分支
    - 根据比较结果改变控制流
    - `beq`(branch if equal)
        - opcode=4
    - `bne`(branch if not equal)
        - opcode=5
- 非条件分支
    - 无条件地改变控制流
    - `j`(jump)

格式：`bep reg1, reg2, L1`
    - 前两个是寄存器操作数，第三个是存储器地址(一个立即数，偏移量)
    - 不同于x86指令，没有标志寄存器，在一条语句中完成了比较和转移

| I         | opcode | rs    | rt    | immediate |
|-----------|--------|-------|-------|-----------|
| 大小(bit) | 6      | 5     | 5     | 16        |
| 位置      | 31~26  | 25~21 | 20~16 | 15~0      |

- 如何发挥16bit的作用？
    - 以当前的PC为基准，16bit偏移量可以表示$\pm 2^{15}$bytes
    - 由于MIPS指令长度固定为32bit，因此我们可以用16bit的立即数来表示每4个字节为一个单位的地址，这样目标地址范围可以扩大4倍。
    - 16bit偏移量可以表示$\pm 2^{17}$bytes
- 目标地址计算方法
    - 分支条件不成立时，PC = PC + 4 = 下一条语句
    - 分支条件成立时，PC = PC + 4  + immediate\*4

对于非条件分支指令

| J         | opcode |  immediate |
|-----------|--------|------------|
| 大小(bit) | 6      |  26        |
| 位置      | 31~26  |  25~0      |

- 不同于条件分支，需要两个寄存器比较，所以可以表示更大的范围
- 目标地址计算方法：New PC = {(PC+4)后取最高4位, address, 00}
- J型指令的目标地址范围：`\pm 2^{28}`bytes
    - 如何到达更远的目标地址？
        - 两次调用j指令
        - 使用jr指令：`jr rs`，可把要转移的目标地址放在寄存器中，这样就可以使用32位的目标地址


## 算数逻辑单元

通过MIPS指令来做示例


### 算数运算和逻辑运算

把编码好的指令，如`add r1, r2, r3`放入IR寄存器中，根据各个域的数值控制电路向ALU发出信号：输入、输出、运算方法等。

在如对于立即数加法：`addi`，ALU接受到信号，通过opcode知道要进行立即数加法，把把源寄存器作为输入，把输出放入目标寄存器。
- 立即数是16bit的，但寄存器是32bit的，要能成功相加，需要扩展16bit
    - MIPS使用补码，所以这个立即数采用符号扩展，不会改变补码的值

对于逻辑运算，与算数运算类似，只是立即数采用0扩展。


### 门电路的基本原理

现代集成电路通常使用MOS晶体管

- N型MOS管
    - Source源：电流流入
    - Drain漏：电流流出
    - Gate门：控制，高电频导通
- P型MOS管
    - Source源：电流流入
    - Drain漏：电流流出
    - Gate门：控制，低电频导通
- 用这两种晶体管就构成了互补型的MOS关：CMOS

逻辑门由晶体管构成，各种逻辑门的结构这里就不说了


### 寄存器的原理

在MIPS结构中，寄存器是由32个位组成，从电路上来说每个bit都是一样的，都是一个 **D触发器**。

- D触发器
    - 具有存储信息能力的基本单元
    - 由若干逻辑门构成，有多种实现方式
    - 主要有1个数据输入、1个数据输出和1个时钟输入
    - 在上升沿，采样输入D的值，传送到输出Q，其余时间输出Q的值不变
    - 要求采样信号前后有一段很短的稳定时间

用32个D触发器构成MIPS的寄存器，在将寄存器用逻辑门相连，就构成了CPU。


### 逻辑运算的实现

ALU中包含很多中运算单元，以与元算单元为例：32位的输入需要32个与逻辑门处理，得到对应的32位输出。ALU包含多个单元，一组输入通过不同的单元，的到多组输出，这时需要一个多选器根据选择信号(opcode)对这些输出进行选择，得到一个32位的输出。


### 加减法的实现

- 半加器
    - 将两个一位二进制数相加
    - 不能将进位位用与加法
- 全加器
    - 由两个半加器组成
    - 能将进位位用与加法

- MIPS对溢出的处理方式
    - 将操作数看做有符号数`add`和`addi`
        - 发生溢出时会产生异常
    - 将操作数看做无符号数`addu`和`addiu`
        - 不处理溢出
- x86对溢出的处理方式
    - 采用溢出标志OF，根据标志寄存器OF来进行相应的操作

对于减法运算，减法可以转换成加法，那么就要对一个数进行取反操作
- 补码表示的二进制数取反
    - 规则：按位取反，末位加一
    - 推导 
    ``` 
    x :010101
    ~x:101010
    ----------
    -1:111111
    
    x + (~x) = -1
    
    (~x) + 1 = -x
    ```

### 加法器的优化

前面将的加法有一个个的全加器串联而成，需要等待进位输入，延迟长。进位像波一样传递，这样的加法器也称为 **行波进位加法器(RCA)** 。

- 超前进位加法器(CLA)
    - 优点： 
        - 计算延迟时间固定为三级门延迟
    - 缺点：
        - 进一步扩宽加法器的位数，则电路变得非常复杂
    - 因此通常使用小规模的CLA拼接形成加法器


## 乘法器和除法器

整数乘法指令相当慢，需要多个时钟周期，然而其他的整数运算(如加法、减法、位移)之需要1个时钟周期。因此编译器使用了一项重要的优化：试着用移位和加法运算的组合来代替乘以常数因子的乘法。

如$x \times 14$，$14=2^3+2^2+2^1$，编译器将乘法重写为(x<<3)+(x<<2)+(x<<1)，将一个乘法代替为3个移位和2个加法。甚至还可以$14=2^4-2^1$。


### 乘法器的实现

观察下列乘法过程：

``` 
      1000
      1001
      ------
      1000
     0000_   好似乘数左移乘
    0000__
   1000___
```

一个N位乘法器需要3个寄存器，分别设为被乘数md，乘mr，结果res。由上列过程得到启发，过程如下：
- 如果被乘数第一位不为0则乘以乘数
- 把结果加到res中
- 乘数右移，被乘数左移
- 如果执行了N次则乘法结束，否则回到第一步

- 对N位乘法器进行优化
    - 1. 加法移位并行
        - 通过控制器，控制移位，在一个时钟周期完成移位操作
    - 2. 减少不必要的硬件资源
        - md由于左移，储存需要的位数是它原始位宽的两倍
            - 取消左移
        - mr右移有效数字每个周期减少1位
            - 用res的低4为存放，因此可以取消mr
        - res每个周期增加1位
            - 增加右移，来代替md的左移，乘积始终放在高4位
        - 加法器参加运输，但实际有效数字自由其位宽的一半
            - md和res的高4位进行运算


### 除法的运算过程

观察除法的运算过程

``` 
                    0001        结果累加，相当于左移
                   0001
                  0000
                 0000
                0000            0010<0000所以商为0
           0010/00000111
                0010____        相当于右移
                 0010
                  0010
                   0010
                   ----
                    0011
                    0010
                    ----
                       1        记录余数
```

过程如下
- 余数寄存器减去除数，检测最高位判断大小
- 除数右移
- 商左移，累加

除法器的优化:
- 1. 硬件资源优化
    - 除数寄存器实际只用了一半
    - 商寄存器初始的空的，从右到左逐位填满
    - 余数初始是满的，有意义的位从左到右逐位减少
- 2. 性能资源优化


## 单周期处理器






















