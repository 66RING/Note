---
title: Computer Organization
date: 2019-12-10
tags: cs
mathjax: true
---

## 简介

- 从纯文本的程序到可执行的编码，以`hello.c`为例
    - 预处理：把头文件的内容直接插入程序文本。结果得到另一个c程序，通常以.i结尾
    - 编译：编译器将本文文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序
    - 汇编：汇编器将hello.s翻译成机器指令(编码)，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中(一个二进制文件)。
    - 链接：hello程序可能会用到许多函数，如printf。printf函数存在与一个名为printf.o的单独编译的与编译好了的目标文件中，这个文件需要以某种形式合并到我们的hello.o程序中。链接器就负责处理这种合并


- 虚拟内存：虚拟内存是一个抽象概念，它为每个进程提供一个假象，即每个进程都在单独的使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间
- 虚拟地址空间的结构：
    - 程序代码和数据
    - 堆：代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的函数时，堆可以在运行时动态伸缩
    - 共享库：大约在地址空间的中间部分是一块用来存放像C标准这样的共享库的代码和数据的区域
    - 栈
    - 内核虚拟内存：地址空间的顶部区域是为内核保留的。不允许任何程序的读写


## 程序结构和执行

### 整数运算

#### 无符号加法

考虑两个非负整数x和y，满足$0 \leq x, y<2^w$。每个数都能表示为w为无符号数字。如果计算他们的和，我们就有一个可能的范围$0 \leq x+y \leq 2^{w+1} - 2$，表示这个和可能需要w+1位。对于固定精度的编程语言会发生溢出。

我们为x和y定义运算$+^u_w, 其中0 \leq x, y < 2^w$，该操作是把整数和x+y截断为w位得到的结果。这也可以被视为一种形式的模运算，对于x+y的位级表示，简单的丢弃任何权重大于$2^{w-1}$的位就可以计算出和模$2^w$。如考虑一个4位数字表示$x=12, y=9,x+y=21([10101])$如果丢掉最高位，我们的到[0101]，也就是十进制的5。也就和值21 mod 16 = 6一致。

> 定义$+^u_w$:
> 
> 对于满足$0 \leq x, y < 2^w$的x和y有
> 
> $$
> x+^u_w y = 
> \begin{cases}
> x+y& ,{x+y<2^w}& 正常\\
> x+y-2^w& ,{2^w \leq x+y < 2^{w+1}}& 溢出
> \end{cases}
> $$

如何判断是否发生了溢出：
- 原理：对在范围$0 \leq x, y \leq UMax_w$中的x和y，令$s = x +^u_w y$。则对计算是，当且仅当s\<x(或等价地s\<y)时发生溢出
- 推导：显然$x+y \geq x$，因此如果s没有溢出$s \geq x$。如果s发生溢出，有$s = x+y-2^w$，假设$y < 2^w$，有$y-2^w < 0$，因此$s = x+(y-2^w) < x$


#### 乘以常数

整数乘法指令相当慢，需要多个时钟周期，然而其他的整数运算(如加法、减法、位移)之需要1个时钟周期。因此编译器使用了一项重要的优化：试着用移位和加法运算的组合来代替乘以常数因子的乘法。

如$x \times 14$，$14=2^3+2^2+2^1$，编译器将乘法重写为(x<<3)+(x<<2)+(x<<1)，将一个乘法代替为3个移位和2个加法。甚至还可以$14=2^4-2^1$。

到这里，无符号数和补码的结果还是相同的


#### 除以2的幂

在大多数机器上，整数除法要比整数乘法更慢：需要30个或者更多的时钟周期。除以2的幂也可以通过用移位(左移)运算来实现。

无符号和补码数分别使用逻辑移位和算数移位来达到目的：
- 逻辑移位
    - 移出的空位用0补上
- 算术移位
    - 对于无符号型，算术移位等同于逻辑移位
    - 对于有符号型，算数左移等同于逻辑左移，算数右移补的是符号位

> 定义$\lfloor a \rfloor$为向下舍入，$\lceil a \rceil$为向上舍入。

对于$x \geq 0$和$y>0$，结果会是$\lfloor x/y \rfloor$，对于$x<0$和$y>0$，结果会是$\lceil x/y \rceil$。也就是说要向下舍入一个正值，而向上舍入一个负值。

- 除以2的幂的无符号数除法
    - 很简单，就直接右移，产生$\lfloor x/2^k \rfloor$
- 除以2的幂的补码，正值情况，向下舍入
    - 也是直接右移，直接右移的结果是向下舍入的
- 除以2的幂的补码，负值情况，向上舍入
    - 不能直接右移，因为直接右移导致结果向下舍入，而我们需要向上舍入
    - 执行算数右移前要加上一个适当的偏执量才能使得结果正确舍入
    - 表达式：(x+(1\<\<k)-1)\>\>k产生数值$\lceil x/2^k \rceil$
    - 偏置技术利用如下属性：对于整数x和y(y>0)，$\lceil x/y \rceil=\lfloor (x+y-1)/y \rfloor$。这样就可以通过逻辑移位来的到向上取整的结果了
    - **推导:** $\lceil x/y \rceil=\lfloor (x+y-1)/y \rfloor$，设$x = qy+r$，其中$0 \leq r < y$，得到(x+y-1)/y=q+(r+y-1)，因此$\lfloor (x+y-1)/y \rfloor = q + \lfloor (r+y-1)/y \rfloor$。当r=0时，后面一项等于0，当r>0时，等于1。级通过给x增加一个偏移量y-1,然后再将除法向下舍入，当y整除x时，我们得到q，否则，得到q+1。


### 浮点数

#### IEEE浮点数表示

定点表示法不能很有效地表示非常大的数字。我们希望通过给定x和y的值，来表示形如$x \times 2^y$的数。
 
> IEEE浮点数标准用$V = (-1)^s \times M \times 2^E$的形式来表示一个数：
> - 符号(sign)
>     - s决定是负数(s=1)还是正数
> - 尾数(significand) M
>     - M是一个二进制小数，它的取值范围是[1, 2)或[0, 1)
>     - 有n位小数字段$frac=f_{n-1}...f_0$编码尾数M，但编码出来的值也依赖于阶码字段是否等于0(规格化的和非规格化的)
> - 阶码(exponent) E
>     - E的作用是对浮点数加权，这个权重是2的E次幂
>     - 由k位的阶码字段组成$exp=e_{k-1}...f_0$来编码阶码E


- 以下是两种常见的格式：单精度和双精度
    - 单精度:s、exp、frac字段分别为1位、k=8位和n=23位，得到一个32位的表示
    - 双精度:s、exp、frac字段分别为1位、k=11位和n=52位，得到一个64位的表示
- 给定位的表示，根据exp的值，被编码的值可以分成三种不同的情况(最后一种情况有两种变种)
    - 规格化的
        - exp字段既不全为0也不全为1
        - 阶码的值E=e-Bias，e是无符号数，而$Bias=2^{k-1}-1$的偏置值
        - 尾数M=1+f，f是frac字段描述的小数值$0 \leq f < 1$
    - 非规格化的值
        - exp字段全为0时
        - 阶码E=1-Bias
        - 尾数M=f
        - 注意和规格化的区别
    - 特殊值
        - 当exp全为1，frac字段全为0时，得到的值表示无穷
        - 当exp全为1，frac字段不全为0时，得到的值表示NaN(Not a Number)

示例：假定用6位格式表示，k=3的阶码位和n=2的尾数位，如下

| 描述           | 位表示     | e   | E  | $2^E$        | f         | M            | $2^E \times M$ | V             | 十进制   | 公式     |
|----------------|------------|-----|----|--------------|-----------|--------------|----------------|---------------|----------|----------|
| 0              | 0 0000 000 | 0   | -6 | $\frac1{64}$ | $\frac08$ | $\frac08$    | $\frac0{512}$  | 0             | 0.0      | E=1-Bias |
| 最小非规格化数 | 0 0000 001 | 0   | -6 | $\frac1{64}$ | $\frac18$ | $\frac18$    | $\frac1{512}$  | $\frac1{512}$ | 0.001953 | M=f      |
|                | 0 0000 010 | 0   | -6 | $\frac1{64}$ | $\frac28$ | $\frac38$    | $\frac2{512}$  | $\frac1{256}$ | 0.003906 |          |
| ...            | ...        | ... | .. | ...          |           |              |                |               |          |          |
| 最大非规格化数 | 0 0000 111 | 0   | -6 | $\frac1{64}$ | $\frac78$ | $\frac78$    | $\frac7{512}$  | $\frac7{512}$ | 0.013672 |          |
| --------       | ------     | --  | -- | ---          | ----      | ----         | ------         | -----         | -----    |          |
| 最小规格化数   | 0 0001 000 | 1   | -6 | $\frac1{64}$ | $\frac08$ | $\frac88$    | $\frac8{512}$  | $\frac1{64}$  | 0.015625 | E=e-Bias |
|                | 0 0001 001 | 1   | -6 | $\frac1{64}$ | $\frac18$ | $\frac98$    | $\frac9{512}$  | $\frac9{256}$ | 0.017578 | M=1+f    |
| ...            | ...        | ... | .. | ...          |           |              |                |               |          |          |
|                | 0 1110 110 | 14  | 7  | 128          | $\frac68$ | $\frac{14}8$ | $\frac{1792}8$ | 224           | 224      |          |
| 最大规格化数   | 0 1110 111 | 14  | 7  | 128          | $\frac78$ | $\frac{15}8$ | $\frac{1920}8$ | 240           | 240      |          |
| --------       | ------     | --  | -- | ---          | ----      | ----         | ------         | -----         | -----    |          |
| 无穷大         | 0 1111 000 | -   | -  | -            | -         | -            | -              | 无穷          | -        |          |


## 程序的机器级表示

### 数据格式

| C声明    | Intel数据类型 | 汇编代码后缀 | 大小(字节) |
|----------|---------------|--------------|------------|
| char   | 字节          | b            | 1          |
| short  | 字            | w            | 2          |
| int    | 双字          | l            | 4          |
| long   | 四字          | q            | 8          |
| char\* | 四字          | q            | 8          |
| float  | 单精度        | s            | 4          |
| double | 双精度        | l            | 8          |


### 访问信息

一个x86-64的CPU包含一组16个储存64位值的通用目的寄存器。每个寄存器都有特殊的用途，它们的名字就反映了这些用途。

| 64寄存器 | 32位寄存器 | 16位寄存器 | 8位寄存器 | 用途         |
|----------|------------|------------|-----------|--------------|
| %rax     | %eax       | %ax        | %ax       | 返回值       |
| %rbx     | %ebx       | %bx        | %bl       | 被调用者保存 |
| %rcx     | %ecx       | %cx        | %cl       | 第4个参数    |
| %rdx     | %edx       | %dx        | %dl       | 第3个参数    |
| %rsi     | %esi       | %si        | %sil      | 第2个参数    |
| %rdi     | %edi       | %di        | %dil      | 第1个参数    |
| %rbp     | %ebp       | %bp        | %bpl      | 被调用者保存 |
| %rsp     | %esp       | %sp        | %spl      | 栈指针       |
| %r8      | %r8d       | %r8w       | %r8b      | 第5个参数    |
| %r9      | %r9d       | %r9w       | %r9b      | 第6个参数    |
| %r10     | %r10d      | %r10w      | %r10b     | 调用者保存   |
| %r11     | %r11d      | %r11w      | %r11b     | 调用者保存   |
| %r12     | %r12d      | %r12w      | %r12b     | 被调用者保存 |
| %r13     | %r13d      | %r13w      | %r13b     | 被调用者保存 |
| %r14     | %r14d      | %r14w      | %r14b     | 被调用者保存 |
| %r15     | %r15d      | %r15w      | %r15b     | 被调用者保存 |

指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。









