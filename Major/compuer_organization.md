---
title: Computer Organization
date: 2019-12-10
tags: cs
mathjax: true
---

## 简介

- 从纯文本的程序到可执行的编码，以`hello.c`为例
    - 预处理：把头文件的内容直接插入程序文本。结果得到另一个c程序，通常以.i结尾
    - 编译：编译器将本文文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序
    - 汇编：汇编器将hello.s翻译成机器指令(编码)，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中(一个二进制文件)。
    - 链接：hello程序可能会用到许多函数，如printf。printf函数存在与一个名为printf.o的单独编译的与编译好了的目标文件中，这个文件需要以某种形式合并到我们的hello.o程序中。链接器就负责处理这种合并


- 虚拟内存：虚拟内存是一个抽象概念，它为每个进程提供一个假象，即每个进程都在单独的使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间
- 虚拟地址空间的结构：
    - 程序代码和数据
    - 堆：代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的函数时，堆可以在运行时动态伸缩
    - 共享库：大约在地址空间的中间部分是一块用来存放像C标准这样的共享库的代码和数据的区域
    - 栈
    - 内核虚拟内存：地址空间的顶部区域是为内核保留的。不允许任何程序的读写


## 程序结构和执行

### 整数运算

#### 无符号加法

考虑两个非负整数x和y，满足$0 \leq x, y<2^w$。每个数都能表示为w为无符号数字。如果计算他们的和，我们就有一个可能的范围$0 \leq x+y \leq 2^{w+1} - 2$，表示这个和可能需要w+1位。对于固定精度的编程语言会发生溢出。

我们为x和y定义运算$+^u_w, 其中0 \leq x, y < 2^w$，该操作是把整数和x+y截断为w位得到的结果。这也可以被视为一种形式的模运算，对于x+y的位级表示，简单的丢弃任何权重大于$2^{w-1}$的位就可以计算出和模$2^w$。如考虑一个4位数字表示$x=12, y=9,x+y=21([10101])$如果丢掉最高位，我们的到[0101]，也就是十进制的5。也就和值21 mod 16 = 6一致。

> 定义$+^u_w$:
> 
> 对于满足$0 \leq x, y < 2^w$的x和y有
> 
> $$
> x+^u_w y = 
> \begin{cases}
> x+y& ,{x+y<2^w}& 正常\\
> x+y-2^w& ,{2^w \leq x+y < 2^{w+1}}& 溢出
> \end{cases}
> $$

如何判断是否发生了溢出：
- 原理：对在范围$0 \leq x, y \leq UMax_w$中的x和y，令$s = x +^u_w y$。则对计算是，当且仅当s\<x(或等价地s\<y)时发生溢出
- 推导：显然$x+y \geq x$，因此如果s没有溢出$s \geq x$。如果s发生溢出，有$s = x+y-2^w$，假设$y < 2^w$，有$y-2^w < 0$，因此$s = x+(y-2^w) < x$


#### 补码加法













